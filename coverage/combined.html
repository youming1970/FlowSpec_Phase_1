
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>engine: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">flowspec-cli/internal/engine/engine.go (91.0%)</option>
				
				<option value="file1">flowspec-cli/internal/engine/jsonlogic_evaluator.go (85.4%)</option>
				
				<option value="file2">flowspec-cli/internal/ingestor/ingestor.go (93.2%)</option>
				
				<option value="file3">flowspec-cli/internal/ingestor/streaming.go (87.1%)</option>
				
				<option value="file4">flowspec-cli/internal/models/servicespec.go (93.6%)</option>
				
				<option value="file5">flowspec-cli/internal/parser/base_parser.go (85.9%)</option>
				
				<option value="file6">flowspec-cli/internal/parser/go_parser.go (100.0%)</option>
				
				<option value="file7">flowspec-cli/internal/parser/java_parser.go (100.0%)</option>
				
				<option value="file8">flowspec-cli/internal/parser/parser.go (80.4%)</option>
				
				<option value="file9">flowspec-cli/internal/parser/typescript_parser.go (100.0%)</option>
				
				<option value="file10">flowspec-cli/internal/renderer/renderer.go (86.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package engine

import (
        "fmt"
        "reflect"
        "runtime"
        "strings"
        "sync"
        "time"

        "flowspec-cli/internal/models"
)

// AlignmentEngine defines the interface for aligning ServiceSpecs with trace data
type AlignmentEngine interface {
        AlignSpecsWithTrace(specs []models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentReport, error)
        AlignSingleSpec(spec models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentResult, error)
        SetEvaluator(evaluator AssertionEvaluator)
        GetEvaluator() AssertionEvaluator
}

// AssertionEvaluator defines the interface for evaluating assertions
type AssertionEvaluator interface {
        EvaluateAssertion(assertion map[string]interface{}, context *EvaluationContext) (*AssertionResult, error)
        ValidateAssertion(assertion map[string]interface{}) error
}

// EvaluationContext provides context for assertion evaluation
type EvaluationContext struct {
        Span       *models.Span
        TraceData  *models.TraceData
        Variables  map[string]interface{}
        Timestamp  time.Time
        mu         sync.RWMutex
}

// AssertionResult represents the result of evaluating an assertion
type AssertionResult struct {
        Passed      bool
        Expected    interface{}
        Actual      interface{}
        Expression  string
        Message     string
        Error       error
}

// DefaultAlignmentEngine implements the AlignmentEngine interface
type DefaultAlignmentEngine struct {
        evaluator AssertionEvaluator
        config    *EngineConfig
        mu        sync.RWMutex
}

// EngineConfig holds configuration for the alignment engine
type EngineConfig struct {
        MaxConcurrency    int           // Maximum number of concurrent alignments
        Timeout           time.Duration // Timeout for individual spec alignment
        EnableMetrics     bool          // Enable performance metrics
        StrictMode        bool          // Strict mode for validation
        SkipMissingSpans  bool          // Skip specs when corresponding spans are not found
}

// SpecMatcher handles matching ServiceSpecs to spans
type SpecMatcher struct {
        matchStrategies []MatchStrategy
        mu              sync.RWMutex
}

// MatchStrategy defines how to match specs to spans
type MatchStrategy interface {
        Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error)
        GetName() string
        GetPriority() int
}

// OperationIDMatcher matches specs to spans by operation ID
type OperationIDMatcher struct{}

// SpanNameMatcher matches specs to spans by span name
type SpanNameMatcher struct{}

// AttributeMatcher matches specs to spans by attributes
type AttributeMatcher struct {
        attributeKey string
}

// ValidationContext manages the context during validation
type ValidationContext struct {
        spec      models.ServiceSpec
        span      *models.Span
        traceData *models.TraceData
        variables map[string]interface{}
        startTime time.Time
        mu        sync.RWMutex
}

// DefaultEngineConfig returns a default engine configuration
func DefaultEngineConfig() *EngineConfig <span class="cov8" title="1">{
        return &amp;EngineConfig{
                MaxConcurrency:   4,
                Timeout:          30 * time.Second,
                EnableMetrics:    true,
                StrictMode:       false,
                SkipMissingSpans: true,
        }
}</span>

// NewAlignmentEngine creates a new alignment engine with default configuration
func NewAlignmentEngine() *DefaultAlignmentEngine <span class="cov8" title="1">{
        return NewAlignmentEngineWithConfig(DefaultEngineConfig())
}</span>

// NewAlignmentEngineWithConfig creates a new alignment engine with custom configuration
func NewAlignmentEngineWithConfig(config *EngineConfig) *DefaultAlignmentEngine <span class="cov8" title="1">{
        engine := &amp;DefaultAlignmentEngine{
                config: config,
        }
        
        // Set default JSONLogic evaluator
        engine.evaluator = NewJSONLogicEvaluator()
        
        return engine
}</span>

// NewEvaluationContext creates a new evaluation context
func NewEvaluationContext(span *models.Span, traceData *models.TraceData) *EvaluationContext <span class="cov8" title="1">{
        return &amp;EvaluationContext{
                Span:      span,
                TraceData: traceData,
                Variables: make(map[string]interface{}),
                Timestamp: time.Now(),
        }
}</span>

// NewSpecMatcher creates a new spec matcher with default strategies
func NewSpecMatcher() *SpecMatcher <span class="cov8" title="1">{
        matcher := &amp;SpecMatcher{
                matchStrategies: make([]MatchStrategy, 0),
        }
        
        // Register default matching strategies in order of priority
        matcher.AddStrategy(&amp;OperationIDMatcher{})
        matcher.AddStrategy(&amp;SpanNameMatcher{})
        matcher.AddStrategy(&amp;AttributeMatcher{attributeKey: "operation.name"})
        
        return matcher
}</span>

// NewValidationContext creates a new validation context
func NewValidationContext(spec models.ServiceSpec, span *models.Span, traceData *models.TraceData) *ValidationContext <span class="cov8" title="1">{
        return &amp;ValidationContext{
                spec:      spec,
                span:      span,
                traceData: traceData,
                variables: make(map[string]interface{}),
                startTime: time.Now(),
        }
}</span>

// AlignmentEngine methods

// AlignSpecsWithTrace implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) AlignSpecsWithTrace(specs []models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentReport, error) <span class="cov8" title="1">{
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return models.NewAlignmentReport(), nil
        }</span>
        
        <span class="cov8" title="1">if traceData == nil || len(traceData.Spans) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("trace data is empty or nil")
        }</span>
        
        // Initialize report with timing information
        <span class="cov8" title="1">startTime := time.Now()
        report := models.NewAlignmentReport()
        report.StartTime = startTime.UnixNano()
        
        // Initialize performance monitoring if enabled
        var performanceInfo models.PerformanceInfo
        if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo = models.PerformanceInfo{
                        SpecsProcessed:      0,
                        SpansMatched:        0,
                        AssertionsEvaluated: 0,
                        ConcurrentWorkers:   0,
                        MemoryUsageMB:       0.0,
                        ProcessingRate:      0.0,
                }
        }</span>
        
        // Create channels for concurrent processing
        <span class="cov8" title="1">specChan := make(chan models.ServiceSpec, len(specs))
        resultChan := make(chan *models.AlignmentResult, len(specs))
        errorChan := make(chan error, len(specs))
        
        // Determine number of workers
        numWorkers := engine.config.MaxConcurrency
        if numWorkers &gt; len(specs) </span><span class="cov8" title="1">{
                numWorkers = len(specs)
        }</span>
        
        // Update performance info with worker count
        <span class="cov8" title="1">if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo.ConcurrentWorkers = numWorkers
        }</span>
        
        // Start workers
        <span class="cov8" title="1">var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        engine.alignmentWorker(specChan, resultChan, errorChan, traceData)
                }</span>()
        }
        
        // Send specs to workers
        <span class="cov8" title="1">for _, spec := range specs </span><span class="cov8" title="1">{
                specChan &lt;- spec
        }</span>
        <span class="cov8" title="1">close(specChan)
        
        // Wait for workers to complete
        go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
                close(errorChan)
        }</span>()
        
        // Collect results and update performance metrics
        <span class="cov8" title="1">var errors []error
        spansMatched := 0
        assertionsEvaluated := 0
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case result, ok := &lt;-resultChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                resultChan = nil
                        }</span> else<span class="cov8" title="1"> {
                                report.AddResult(*result)
                                
                                // Update performance metrics
                                if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                                        performanceInfo.SpecsProcessed++
                                        spansMatched += len(result.MatchedSpans)
                                        assertionsEvaluated += result.AssertionsTotal
                                }</span>
                        }
                case err, ok := &lt;-errorChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                errorChan = nil
                        }</span> else<span class="cov0" title="0"> {
                                errors = append(errors, err)
                        }</span>
                }
                
                <span class="cov8" title="1">if resultChan == nil &amp;&amp; errorChan == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        
        // Finalize report timing and performance information
        <span class="cov8" title="1">endTime := time.Now()
        report.EndTime = endTime.UnixNano()
        report.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
        
        // Complete performance information
        if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo.SpansMatched = spansMatched
                performanceInfo.AssertionsEvaluated = assertionsEvaluated
                
                // Calculate processing rate (specs per second)
                executionSeconds := float64(report.ExecutionTime) / 1e9
                if executionSeconds &gt; 0 </span><span class="cov8" title="1">{
                        performanceInfo.ProcessingRate = float64(performanceInfo.SpecsProcessed) / executionSeconds
                }</span>
                
                // Get memory usage (simplified - in a real implementation, you'd use runtime.MemStats)
                <span class="cov8" title="1">performanceInfo.MemoryUsageMB = engine.getMemoryUsageMB()
                
                report.PerformanceInfo = performanceInfo</span>
        }
        
        // Return error if any critical errors occurred
        <span class="cov8" title="1">if len(errors) &gt; 0 &amp;&amp; len(report.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("alignment failed with %d errors: %v", len(errors), errors[0])
        }</span>
        
        <span class="cov8" title="1">return report, nil</span>
}

// AlignSingleSpec implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) AlignSingleSpec(spec models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentResult, error) <span class="cov8" title="1">{
        if engine.evaluator == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no assertion evaluator configured")
        }</span>
        
        <span class="cov8" title="1">startTime := time.Now()
        result := models.NewAlignmentResult(spec.OperationID)
        result.StartTime = startTime.UnixNano()
        
        // Find matching spans
        matcher := NewSpecMatcher()
        matchingSpans, err := matcher.FindMatchingSpans(spec, traceData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find matching spans: %w", err)
        }</span>
        
        <span class="cov8" title="1">if len(matchingSpans) == 0 </span><span class="cov8" title="1">{
                if engine.config.SkipMissingSpans </span><span class="cov8" title="1">{
                        result.AddValidationDetail(*models.NewValidationDetail(
                                "matching", "span_match", "found", "found", 
                                "No matching spans found for operation: "+spec.OperationID))
                        result.Status = models.StatusSkipped // Set after adding detail
                }</span> else<span class="cov0" title="0"> {
                        result.AddValidationDetail(*models.NewValidationDetail(
                                "matching", "span_match", "found", "not_found", 
                                "Required spans not found for operation: "+spec.OperationID))
                        // Status will be set to FAILED by updateStatus due to mismatch
                }</span>
                
                // Finalize timing
                <span class="cov8" title="1">endTime := time.Now()
                result.EndTime = endTime.UnixNano()
                result.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
                return result, nil</span>
        }
        
        // Record matched span IDs
        <span class="cov8" title="1">result.MatchedSpans = make([]string, len(matchingSpans))
        for i, span := range matchingSpans </span><span class="cov8" title="1">{
                result.MatchedSpans[i] = span.SpanID
        }</span>
        
        // Evaluate assertions for each matching span
        <span class="cov8" title="1">for _, span := range matchingSpans </span><span class="cov8" title="1">{
                if err := engine.evaluateSpecForSpan(spec, span, traceData, result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to evaluate spec for span %s: %w", span.SpanID, err)
                }</span>
        }
        
        // Finalize timing
        <span class="cov8" title="1">endTime := time.Now()
        result.EndTime = endTime.UnixNano()
        result.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
        return result, nil</span>
}

// SetEvaluator implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) SetEvaluator(evaluator AssertionEvaluator) <span class="cov8" title="1">{
        engine.mu.Lock()
        defer engine.mu.Unlock()
        engine.evaluator = evaluator
}</span>

// GetEvaluator implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) GetEvaluator() AssertionEvaluator <span class="cov8" title="1">{
        engine.mu.RLock()
        defer engine.mu.RUnlock()
        return engine.evaluator
}</span>

// alignmentWorker processes specs concurrently
func (engine *DefaultAlignmentEngine) alignmentWorker(specChan &lt;-chan models.ServiceSpec, resultChan chan&lt;- *models.AlignmentResult, errorChan chan&lt;- error, traceData *models.TraceData) <span class="cov8" title="1">{
        for spec := range specChan </span><span class="cov8" title="1">{
                result, err := engine.AlignSingleSpec(spec, traceData)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- result
                }</span>
        }
}

// evaluateSpecForSpan evaluates a spec against a specific span
func (engine *DefaultAlignmentEngine) evaluateSpecForSpan(spec models.ServiceSpec, span *models.Span, traceData *models.TraceData, result *models.AlignmentResult) error <span class="cov8" title="1">{
        context := NewEvaluationContext(span, traceData)
        
        // Populate context with span data
        engine.populateEvaluationContext(context, span)
        
        // Evaluate preconditions
        if len(spec.Preconditions) &gt; 0 </span><span class="cov8" title="1">{
                preconditionResult, err := engine.evaluator.EvaluateAssertion(spec.Preconditions, context)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to evaluate preconditions: %w", err)
                }</span>
                
                <span class="cov8" title="1">detail := engine.createDetailedValidationDetail(
                        "precondition", 
                        spec.Preconditions,
                        preconditionResult,
                        span,
                        context,
                )
                result.AddValidationDetail(*detail)</span>
        }
        
        // Evaluate postconditions
        <span class="cov8" title="1">if len(spec.Postconditions) &gt; 0 </span><span class="cov8" title="1">{
                postconditionResult, err := engine.evaluator.EvaluateAssertion(spec.Postconditions, context)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to evaluate postconditions: %w", err)
                }</span>
                
                <span class="cov8" title="1">detail := engine.createDetailedValidationDetail(
                        "postcondition",
                        spec.Postconditions,
                        postconditionResult,
                        span,
                        context,
                )
                result.AddValidationDetail(*detail)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// createDetailedValidationDetail creates a detailed validation detail with enhanced error information
func (engine *DefaultAlignmentEngine) createDetailedValidationDetail(
        detailType string,
        assertion map[string]interface{},
        assertionResult *AssertionResult,
        span *models.Span,
        context *EvaluationContext,
) *models.ValidationDetail <span class="cov8" title="1">{
        // Create enhanced validation detail
        detail := &amp;models.ValidationDetail{
                Type:        detailType,
                Expression:  assertionResult.Expression,
                Expected:    assertionResult.Expected,
                Actual:      assertionResult.Actual,
                Message:     engine.generateActionableErrorMessage(detailType, assertion, assertionResult, span, context),
                SpanContext: span,
        }
        
        // Add failure analysis if assertion failed
        if !assertionResult.Passed </span><span class="cov8" title="1">{
                detail.FailureReason = engine.analyzeFailureReason(assertion, assertionResult, context)
                detail.ContextInfo = engine.extractContextInfo(span, context)
                detail.Suggestions = engine.generateSuggestions(detailType, assertion, assertionResult, span)
        }</span>
        
        <span class="cov8" title="1">return detail</span>
}

// generateActionableErrorMessage creates a detailed, actionable error message
func (engine *DefaultAlignmentEngine) generateActionableErrorMessage(
        detailType string,
        assertion map[string]interface{},
        result *AssertionResult,
        span *models.Span,
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s assertion passed: %s", 
                        strings.Title(detailType), result.Message)
        }</span>
        
        // Build detailed failure message
        <span class="cov8" title="1">var msgBuilder strings.Builder
        
        msgBuilder.WriteString(fmt.Sprintf("%s assertion failed in span '%s' (ID: %s)\n", 
                strings.Title(detailType), span.Name, span.SpanID))
        
        // Add assertion details with enhanced context
        msgBuilder.WriteString(fmt.Sprintf("Assertion: %s\n", result.Expression))
        
        // Try to extract more meaningful expected/actual values from the assertion
        expectedVal, actualVal := engine.extractMeaningfulValues(assertion, result, context)
        msgBuilder.WriteString(fmt.Sprintf("Expected: %v (type: %T)\n", expectedVal, expectedVal))
        msgBuilder.WriteString(fmt.Sprintf("Actual: %v (type: %T)\n", actualVal, actualVal))
        
        // Add JSONLogic evaluation result for reference
        msgBuilder.WriteString(fmt.Sprintf("JSONLogic Result: Expected %v, Got %v\n", result.Expected, result.Actual))
        
        // Add span context
        msgBuilder.WriteString(fmt.Sprintf("Span Status: %s", span.Status.Code))
        if span.Status.Message != "" </span><span class="cov8" title="1">{
                msgBuilder.WriteString(fmt.Sprintf(" - %s", span.Status.Message))
        }</span>
        <span class="cov8" title="1">msgBuilder.WriteString("\n")
        
        // Add relevant span attributes
        if len(span.Attributes) &gt; 0 </span><span class="cov8" title="1">{
                msgBuilder.WriteString("Relevant Span Attributes:\n")
                for key, value := range span.Attributes </span><span class="cov8" title="1">{
                        msgBuilder.WriteString(fmt.Sprintf("  %s: %v\n", key, value))
                }</span>
        }
        
        // Add trace context
        <span class="cov8" title="1">msgBuilder.WriteString(fmt.Sprintf("Trace ID: %s\n", span.TraceID))
        if span.ParentID != "" </span><span class="cov8" title="1">{
                msgBuilder.WriteString(fmt.Sprintf("Parent Span ID: %s\n", span.ParentID))
        }</span>
        
        <span class="cov8" title="1">return msgBuilder.String()</span>
}

// extractMeaningfulValues attempts to extract the actual values being compared from the assertion
func (engine *DefaultAlignmentEngine) extractMeaningfulValues(
        assertion map[string]interface{},
        result *AssertionResult,
        context *EvaluationContext,
) (interface{}, interface{}) <span class="cov8" title="1">{
        // For simple equality comparisons, try to extract the actual values
        if eqAssertion, ok := assertion["=="]; ok </span><span class="cov8" title="1">{
                if eqSlice, ok := eqAssertion.([]interface{}); ok &amp;&amp; len(eqSlice) == 2 </span><span class="cov8" title="1">{
                        // First element might be a variable reference
                        if varRef, ok := eqSlice[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if varName, ok := varRef["var"].(string); ok </span><span class="cov8" title="1">{
                                        if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov8" title="1">{
                                                return eqSlice[1], actualValue // expected, actual
                                        }</span>
                                        // Try with underscore conversion for JSONLogic compatibility
                                        <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                        if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[1], actualValue // expected, actual
                                        }</span>
                                }
                        }
                        // Second element might be a variable reference
                        <span class="cov8" title="1">if varRef, ok := eqSlice[1].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                        if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[0], actualValue // expected, actual
                                        }</span>
                                        // Try with underscore conversion for JSONLogic compatibility
                                        <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                        if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[0], actualValue // expected, actual
                                        }</span>
                                }
                        }
                }
        }
        
        // For other comparison operators, try similar extraction
        <span class="cov8" title="1">for op, opAssertion := range assertion </span><span class="cov8" title="1">{
                switch op </span>{
                case "!=", "&gt;", "&lt;", "&gt;=", "&lt;=":<span class="cov0" title="0">
                        if opSlice, ok := opAssertion.([]interface{}); ok &amp;&amp; len(opSlice) == 2 </span><span class="cov0" title="0">{
                                // Check if first element is a variable
                                if varRef, ok := opSlice[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                                if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[1], actualValue // expected, actual
                                                }</span>
                                                // Try with underscore conversion
                                                <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                                if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[1], actualValue // expected, actual
                                                }</span>
                                        }
                                }
                                // Check if second element is a variable
                                <span class="cov0" title="0">if varRef, ok := opSlice[1].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                                if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[0], actualValue // expected, actual
                                                }</span>
                                                // Try with underscore conversion
                                                <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                                if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[0], actualValue // expected, actual
                                                }</span>
                                        }
                                }
                        }
                }
        }
        
        // Fallback to JSONLogic result values
        <span class="cov8" title="1">return result.Expected, result.Actual</span>
}

// analyzeFailureReason analyzes why an assertion failed and provides detailed reasoning
func (engine *DefaultAlignmentEngine) analyzeFailureReason(
        assertion map[string]interface{},
        result *AssertionResult,
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Analyze the type of failure
        <span class="cov8" title="1">var reasons []string
        
        // Type mismatch analysis
        if result.Expected != nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                expectedType := reflect.TypeOf(result.Expected)
                actualType := reflect.TypeOf(result.Actual)
                
                if expectedType != actualType </span><span class="cov8" title="1">{
                        reasons = append(reasons, fmt.Sprintf(
                                "Type mismatch: expected %s but got %s", 
                                expectedType, actualType))
                }</span>
        }
        
        // Null/nil value analysis
        <span class="cov8" title="1">if result.Expected != nil &amp;&amp; result.Actual == nil </span><span class="cov8" title="1">{
                reasons = append(reasons, "Expected non-nil value but got nil")
        }</span> else<span class="cov8" title="1"> if result.Expected == nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                reasons = append(reasons, "Expected nil value but got non-nil")
        }</span>
        
        // Numeric comparison analysis
        <span class="cov8" title="1">if isNumeric(result.Expected) &amp;&amp; isNumeric(result.Actual) </span><span class="cov8" title="1">{
                expectedNum := toFloat64(result.Expected)
                actualNum := toFloat64(result.Actual)
                diff := actualNum - expectedNum
                
                if diff != 0 </span><span class="cov8" title="1">{
                        reasons = append(reasons, fmt.Sprintf(
                                "Numeric difference: actual value is %.2f %s than expected", 
                                abs(diff), 
                                map[bool]string{true: "greater", false: "less"}[diff &gt; 0]))
                }</span>
        }
        
        // String comparison analysis
        <span class="cov8" title="1">if expectedStr, ok := result.Expected.(string); ok </span><span class="cov8" title="1">{
                if actualStr, ok := result.Actual.(string); ok </span><span class="cov8" title="1">{
                        if len(expectedStr) != len(actualStr) </span><span class="cov8" title="1">{
                                reasons = append(reasons, fmt.Sprintf(
                                        "String length mismatch: expected %d characters, got %d", 
                                        len(expectedStr), len(actualStr)))
                        }</span>
                        
                        // Find first difference
                        <span class="cov8" title="1">minLen := min(len(expectedStr), len(actualStr))
                        for i := 0; i &lt; minLen; i++ </span><span class="cov8" title="1">{
                                if expectedStr[i] != actualStr[i] </span><span class="cov8" title="1">{
                                        reasons = append(reasons, fmt.Sprintf(
                                                "First difference at position %d: expected '%c', got '%c'", 
                                                i, expectedStr[i], actualStr[i]))
                                        break</span>
                                }
                        }
                }
        }
        
        // JSONLogic specific analysis
        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                reasons = append(reasons, fmt.Sprintf("JSONLogic evaluation error: %v", result.Error))
        }</span>
        
        // Variable resolution analysis
        <span class="cov8" title="1">if len(reasons) == 0 </span><span class="cov8" title="1">{
                reasons = append(reasons, engine.analyzeVariableResolution(assertion, context))
        }</span>
        
        <span class="cov8" title="1">if len(reasons) == 0 </span><span class="cov0" title="0">{
                return "Assertion evaluated to false but specific reason could not be determined"
        }</span>
        
        <span class="cov8" title="1">return strings.Join(reasons, "; ")</span>
}

// analyzeVariableResolution analyzes potential variable resolution issues
func (engine *DefaultAlignmentEngine) analyzeVariableResolution(
        assertion map[string]interface{},
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        variables := engine.extractVariablesFromAssertion(assertion)
        var issues []string
        
        for _, variable := range variables </span><span class="cov8" title="1">{
                if value, exists := context.GetVariable(variable); !exists </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Variable '%s' not found in context", variable))
                }</span> else<span class="cov8" title="1"> if value == nil </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Variable '%s' is nil", variable))
                }</span>
        }
        
        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return "Variable resolution issues: " + strings.Join(issues, ", ")
        }</span>
        
        <span class="cov8" title="1">return "Unknown assertion failure reason"</span>
}

// extractVariablesFromAssertion extracts variable references from a JSONLogic assertion
func (engine *DefaultAlignmentEngine) extractVariablesFromAssertion(assertion map[string]interface{}) []string <span class="cov8" title="1">{
        var variables []string
        engine.extractVariablesRecursive(assertion, &amp;variables)
        return variables
}</span>

// extractVariablesRecursive recursively extracts variables from nested structures
func (engine *DefaultAlignmentEngine) extractVariablesRecursive(obj interface{}, variables *[]string) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        if key == "var" </span><span class="cov8" title="1">{
                                if varName, ok := value.(string); ok </span><span class="cov8" title="1">{
                                        *variables = append(*variables, varName)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                engine.extractVariablesRecursive(value, variables)
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        engine.extractVariablesRecursive(item, variables)
                }</span>
        }
}

// extractContextInfo extracts relevant context information for debugging
func (engine *DefaultAlignmentEngine) extractContextInfo(span *models.Span, context *EvaluationContext) map[string]interface{} <span class="cov8" title="1">{
        info := make(map[string]interface{})
        
        // Span information
        info["span"] = map[string]interface{}{
                "id":         span.SpanID,
                "name":       span.Name,
                "trace_id":   span.TraceID,
                "parent_id":  span.ParentID,
                "start_time": span.StartTime,
                "end_time":   span.EndTime,
                "duration":   span.GetDuration(),
                "status":     span.Status,
                "has_error":  span.HasError(),
                "is_root":    span.IsRoot(),
        }
        
        // Available attributes
        info["attributes"] = span.Attributes
        
        // Available events
        if len(span.Events) &gt; 0 </span><span class="cov8" title="1">{
                events := make([]map[string]interface{}, len(span.Events))
                for i, event := range span.Events </span><span class="cov8" title="1">{
                        events[i] = map[string]interface{}{
                                "name":       event.Name,
                                "timestamp":  event.Timestamp,
                                "attributes": event.Attributes,
                        }
                }</span>
                <span class="cov8" title="1">info["events"] = events</span>
        }
        
        // Context variables
        <span class="cov8" title="1">info["variables"] = context.GetAllVariables()
        
        // Trace information
        if context.TraceData != nil </span><span class="cov8" title="1">{
                info["trace"] = map[string]interface{}{
                        "id":         context.TraceData.TraceID,
                        "span_count": len(context.TraceData.Spans),
                }
                
                if context.TraceData.RootSpan != nil </span><span class="cov8" title="1">{
                        info["trace"].(map[string]interface{})["root_span"] = map[string]interface{}{
                                "id":   context.TraceData.RootSpan.SpanID,
                                "name": context.TraceData.RootSpan.Name,
                        }
                }</span>
        }
        
        <span class="cov8" title="1">return info</span>
}

// generateSuggestions generates actionable suggestions for fixing assertion failures
func (engine *DefaultAlignmentEngine) generateSuggestions(
        detailType string,
        assertion map[string]interface{},
        result *AssertionResult,
        span *models.Span,
) []string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">var suggestions []string
        
        // Type-specific suggestions
        if result.Expected != nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                expectedType := reflect.TypeOf(result.Expected)
                actualType := reflect.TypeOf(result.Actual)
                
                if expectedType != actualType </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, fmt.Sprintf(
                                "Consider converting the actual value to %s or updating the assertion to expect %s",
                                expectedType, actualType))
                }</span>
        }
        
        // Null value suggestions
        <span class="cov8" title="1">if result.Expected != nil &amp;&amp; result.Actual == nil </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check if the span attribute or variable exists and has a non-nil value")
        }</span>
        
        // Numeric comparison suggestions
        <span class="cov8" title="1">if isNumeric(result.Expected) &amp;&amp; isNumeric(result.Actual) </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Verify the expected numeric value or check if the span attribute contains the correct numeric data")
        }</span>
        
        // String comparison suggestions
        <span class="cov8" title="1">if _, expectedIsString := result.Expected.(string); expectedIsString </span><span class="cov8" title="1">{
                if _, actualIsString := result.Actual.(string); actualIsString </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, 
                                "Check for case sensitivity, whitespace, or encoding differences in string values")
                }</span>
        }
        
        // Span-specific suggestions
        <span class="cov8" title="1">if span.HasError() </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "The span has an error status - consider checking if this affects the expected behavior")
        }</span>
        
        // General suggestions
        <span class="cov8" title="1">suggestions = append(suggestions, 
                "Review the span attributes and trace data to ensure the assertion logic matches the actual service behavior")
        
        if detailType == "precondition" </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Precondition failures may indicate that the service was called with unexpected input parameters")
        }</span> else<span class="cov8" title="1"> if detailType == "postcondition" </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Postcondition failures may indicate that the service behavior has changed or the assertion needs updating")
        }</span>
        
        <span class="cov8" title="1">return suggestions</span>
}

// populateEvaluationContext populates the evaluation context with span data
func (engine *DefaultAlignmentEngine) populateEvaluationContext(context *EvaluationContext, span *models.Span) <span class="cov8" title="1">{
        context.mu.Lock()
        defer context.mu.Unlock()
        
        // Add span attributes to context
        for key, value := range span.Attributes </span><span class="cov8" title="1">{
                // Keep original key for backward compatibility
                context.Variables[key] = value
                // Also add with underscores for JSONLogic compatibility
                safeKey := strings.ReplaceAll(key, ".", "_")
                if safeKey != key </span><span class="cov8" title="1">{
                        context.Variables[safeKey] = value
                }</span>
        }
        
        // Add span metadata
        <span class="cov8" title="1">context.Variables["span.id"] = span.SpanID
        context.Variables["span.name"] = span.Name
        context.Variables["span.start_time"] = span.StartTime
        context.Variables["span.end_time"] = span.EndTime
        context.Variables["span.duration"] = span.GetDuration()
        context.Variables["span.status.code"] = span.Status.Code
        context.Variables["span.status.message"] = span.Status.Message
        context.Variables["span.has_error"] = span.HasError()
        context.Variables["span.is_root"] = span.IsRoot()
        
        // Add trace metadata
        context.Variables["trace.id"] = span.TraceID
        if context.TraceData != nil </span><span class="cov8" title="1">{
                context.Variables["trace.span_count"] = len(context.TraceData.Spans)
                if context.TraceData.RootSpan != nil </span><span class="cov8" title="1">{
                        context.Variables["trace.root_span.id"] = context.TraceData.RootSpan.SpanID
                }</span>
        }
}

// EvaluationContext methods

// GetVariable gets a variable from the context
func (ctx *EvaluationContext) GetVariable(key string) (interface{}, bool) <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        value, exists := ctx.Variables[key]
        return value, exists
}</span>

// SetVariable sets a variable in the context
func (ctx *EvaluationContext) SetVariable(key string, value interface{}) <span class="cov8" title="1">{
        ctx.mu.Lock()
        defer ctx.mu.Unlock()
        ctx.Variables[key] = value
}</span>

// GetAllVariables returns a copy of all variables
func (ctx *EvaluationContext) GetAllVariables() map[string]interface{} <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        
        result := make(map[string]interface{})
        for key, value := range ctx.Variables </span><span class="cov8" title="1">{
                result[key] = value
        }</span>
        <span class="cov8" title="1">return result</span>
}

// SpecMatcher methods

// AddStrategy adds a matching strategy
func (sm *SpecMatcher) AddStrategy(strategy MatchStrategy) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.matchStrategies = append(sm.matchStrategies, strategy)
}</span>

// FindMatchingSpans finds spans that match the given spec
func (sm *SpecMatcher) FindMatchingSpans(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        
        // Try each strategy in order of priority
        for _, strategy := range sm.matchStrategies </span><span class="cov8" title="1">{
                spans, err := strategy.Match(spec, traceData)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Try next strategy
                }
                
                <span class="cov8" title="1">if len(spans) &gt; 0 </span><span class="cov8" title="1">{
                        return spans, nil
                }</span>
        }
        
        // No matching spans found
        <span class="cov8" title="1">return []*models.Span{}, nil</span>
}

// MatchStrategy implementations

// OperationIDMatcher methods

// Match implements the MatchStrategy interface
func (matcher *OperationIDMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if operationID, ok := span.Attributes["operation.id"].(string); ok </span><span class="cov8" title="1">{
                        if operationID == spec.OperationID </span><span class="cov8" title="1">{
                                matchingSpans = append(matchingSpans, span)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *OperationIDMatcher) GetName() string <span class="cov8" title="1">{
        return "operation_id"
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *OperationIDMatcher) GetPriority() int <span class="cov8" title="1">{
        return 100 // Highest priority
}</span>

// SpanNameMatcher methods

// Match implements the MatchStrategy interface
func (matcher *SpanNameMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        // Try to match by span name (use operation ID as span name)
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if span.Name == spec.OperationID </span><span class="cov8" title="1">{
                        matchingSpans = append(matchingSpans, span)
                }</span>
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *SpanNameMatcher) GetName() string <span class="cov8" title="1">{
        return "span_name"
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *SpanNameMatcher) GetPriority() int <span class="cov8" title="1">{
        return 80 // High priority
}</span>

// AttributeMatcher methods

// Match implements the MatchStrategy interface
func (matcher *AttributeMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if value, ok := span.Attributes[matcher.attributeKey].(string); ok </span><span class="cov8" title="1">{
                        if value == spec.OperationID </span><span class="cov8" title="1">{
                                matchingSpans = append(matchingSpans, span)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *AttributeMatcher) GetName() string <span class="cov8" title="1">{
        return fmt.Sprintf("attribute_%s", matcher.attributeKey)
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *AttributeMatcher) GetPriority() int <span class="cov8" title="1">{
        return 60 // Medium priority
}</span>

// ValidationContext methods

// GetSpec returns the spec being validated
func (ctx *ValidationContext) GetSpec() models.ServiceSpec <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.spec
}</span>

// GetSpan returns the span being validated
func (ctx *ValidationContext) GetSpan() *models.Span <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.span
}</span>

// GetTraceData returns the trace data
func (ctx *ValidationContext) GetTraceData() *models.TraceData <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.traceData
}</span>

// GetElapsedTime returns the elapsed time since validation started
func (ctx *ValidationContext) GetElapsedTime() time.Duration <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return time.Since(ctx.startTime)
}</span>

// SetVariable sets a variable in the validation context
func (ctx *ValidationContext) SetVariable(key string, value interface{}) <span class="cov8" title="1">{
        ctx.mu.Lock()
        defer ctx.mu.Unlock()
        ctx.variables[key] = value
}</span>

// GetVariable gets a variable from the validation context
func (ctx *ValidationContext) GetVariable(key string) (interface{}, bool) <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        value, exists := ctx.variables[key]
        return value, exists
}</span>

// Utility functions

// isNumeric checks if a value is numeric
func isNumeric(value interface{}) bool <span class="cov8" title="1">{
        switch value.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return true</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov8" title="1">
                return true</span>
        case float32, float64:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// toFloat64 converts a numeric value to float64
func toFloat64(value interface{}) float64 <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int8:<span class="cov8" title="1">
                return float64(v)</span>
        case int16:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov8" title="1">
                return float64(v)</span>
        case int64:<span class="cov8" title="1">
                return float64(v)</span>
        case uint:<span class="cov8" title="1">
                return float64(v)</span>
        case uint8:<span class="cov8" title="1">
                return float64(v)</span>
        case uint16:<span class="cov8" title="1">
                return float64(v)</span>
        case uint32:<span class="cov8" title="1">
                return float64(v)</span>
        case uint64:<span class="cov8" title="1">
                return float64(v)</span>
        case float32:<span class="cov8" title="1">
                return float64(v)</span>
        case float64:<span class="cov8" title="1">
                return v</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// abs returns the absolute value of a float64
func abs(x float64) float64 <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// getMemoryUsageMB returns the current memory usage in MB
func (engine *DefaultAlignmentEngine) getMemoryUsageMB() float64 <span class="cov8" title="1">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        // Return allocated memory in MB
        return float64(m.Alloc) / 1024 / 1024
}</span>

// ValidateEngineConfig validates the engine configuration
func ValidateEngineConfig(config *EngineConfig) error <span class="cov8" title="1">{
        if config.MaxConcurrency &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxConcurrency must be positive, got %d", config.MaxConcurrency)
        }</span>
        
        <span class="cov8" title="1">if config.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Timeout must be positive, got %s", config.Timeout)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/diegoholiveira/jsonlogic/v3"
)

// JSONLogicEvaluator implements the AssertionEvaluator interface using JSONLogic
type JSONLogicEvaluator struct {
        config *JSONLogicConfig
}

// JSONLogicConfig holds configuration for JSONLogic evaluation
type JSONLogicConfig struct {
        MaxDepth         int           // Maximum recursion depth for expressions
        Timeout          time.Duration // Timeout for individual expression evaluation
        StrictMode       bool          // Strict mode for type checking
        AllowedOperators []string      // List of allowed JSONLogic operators (empty = all allowed)
        SandboxMode      bool          // Enable sandbox mode for security
}

// DefaultJSONLogicConfig returns a default configuration for JSONLogic evaluation
func DefaultJSONLogicConfig() *JSONLogicConfig <span class="cov8" title="1">{
        return &amp;JSONLogicConfig{
                MaxDepth:         10,
                Timeout:          5 * time.Second,
                StrictMode:       false,
                AllowedOperators: []string{}, // Allow all operators by default
                SandboxMode:      true,
        }
}</span>

// NewJSONLogicEvaluator creates a new JSONLogic evaluator with default configuration
func NewJSONLogicEvaluator() *JSONLogicEvaluator <span class="cov8" title="1">{
        return NewJSONLogicEvaluatorWithConfig(DefaultJSONLogicConfig())
}</span>

// NewJSONLogicEvaluatorWithConfig creates a new JSONLogic evaluator with custom configuration
func NewJSONLogicEvaluatorWithConfig(config *JSONLogicConfig) *JSONLogicEvaluator <span class="cov8" title="1">{
        return &amp;JSONLogicEvaluator{
                config: config,
        }
}</span>

// EvaluateAssertion implements the AssertionEvaluator interface
func (evaluator *JSONLogicEvaluator) EvaluateAssertion(assertion map[string]interface{}, context *EvaluationContext) (*AssertionResult, error) <span class="cov8" title="1">{
        if assertion == nil || len(assertion) == 0 </span><span class="cov8" title="1">{
                return &amp;AssertionResult{
                        Passed:     true,
                        Expected:   true,
                        Actual:     true,
                        Expression: "empty_assertion",
                        Message:    "Empty assertion always passes",
                }, nil
        }</span>

        // Build evaluation data from context
        <span class="cov8" title="1">data, err := evaluator.buildEvaluationData(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build evaluation data: %w", err)
        }</span>

        // Validate assertion before evaluation if in strict mode
        <span class="cov8" title="1">if evaluator.config.StrictMode </span><span class="cov0" title="0">{
                if err := evaluator.ValidateAssertion(assertion); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("assertion validation failed: %w", err)
                }</span>
        }

        // Apply JSONLogic with timeout protection
        <span class="cov8" title="1">result, err := evaluator.applyWithTimeout(assertion, data)
        if err != nil </span><span class="cov8" title="1">{
                assertionJSON, _ := json.Marshal(assertion)
                return &amp;AssertionResult{
                        Passed:     false,
                        Expected:   true,
                        Actual:     false,
                        Expression: string(assertionJSON),
                        Message:    fmt.Sprintf("JSONLogic evaluation failed: %v", err),
                        Error:      err,
                }, nil
        }</span>

        // Convert result to boolean
        <span class="cov8" title="1">passed := evaluator.convertToBool(result)

        assertionJSON, _ := json.Marshal(assertion)
        return &amp;AssertionResult{
                Passed:     passed,
                Expected:   true,
                Actual:     result,
                Expression: string(assertionJSON),
                Message:    evaluator.buildResultMessage(passed, assertion, result),
        }, nil</span>
}

// ValidateAssertion implements the AssertionEvaluator interface
func (evaluator *JSONLogicEvaluator) ValidateAssertion(assertion map[string]interface{}) error <span class="cov8" title="1">{
        if assertion == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("assertion cannot be nil")
        }</span>

        // Check for allowed operators if configured
        <span class="cov8" title="1">if len(evaluator.config.AllowedOperators) &gt; 0 </span><span class="cov8" title="1">{
                if err := evaluator.validateOperators(assertion, evaluator.config.AllowedOperators); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("operator validation failed: %w", err)
                }</span>
        }

        // Check maximum depth
        <span class="cov8" title="1">if err := evaluator.validateDepth(assertion, 0, evaluator.config.MaxDepth); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("depth validation failed: %w", err)
        }</span>

        // Try to marshal to JSON to ensure it's valid
        <span class="cov8" title="1">_, err := json.Marshal(assertion)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("assertion is not valid JSON: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BuildEvaluationData builds the data context for JSONLogic evaluation (exported for testing)
func (evaluator *JSONLogicEvaluator) BuildEvaluationData(context *EvaluationContext) (map[string]interface{}, error) <span class="cov0" title="0">{
        return evaluator.buildEvaluationData(context)
}</span>

// buildEvaluationData builds the data context for JSONLogic evaluation
func (evaluator *JSONLogicEvaluator) buildEvaluationData(context *EvaluationContext) (map[string]interface{}, error) <span class="cov8" title="1">{
        if context == nil </span><span class="cov8" title="1">{
                return map[string]interface{}{}, nil
        }</span>

        <span class="cov8" title="1">data := make(map[string]interface{})

        // Add span data if available
        if context.Span != nil </span><span class="cov8" title="1">{
                span := context.Span
                
                // Span basic information
                data["span"] = map[string]interface{}{
                        "id":         span.SpanID,
                        "name":       span.Name,
                        "trace_id":   span.TraceID,
                        "parent_id":  span.ParentID,
                        "start_time": span.StartTime,
                        "end_time":   span.EndTime,
                        "duration":   span.GetDuration(),
                        "status": map[string]interface{}{
                                "code":    span.Status.Code,
                                "message": span.Status.Message,
                        },
                        "has_error": span.HasError(),
                        "is_root":   span.IsRoot(),
                }

                // Add span attributes directly to root level for easier access
                // Replace dots with underscores to avoid JSONLogic property access issues
                for key, value := range span.Attributes </span><span class="cov8" title="1">{
                        // Keep original key for backward compatibility
                        data[key] = value
                        // Also add with underscores for JSONLogic compatibility
                        safeKey := strings.ReplaceAll(key, ".", "_")
                        if safeKey != key </span><span class="cov8" title="1">{
                                data[safeKey] = value
                        }</span>
                }

                // Add span attributes under "attributes" namespace as well
                <span class="cov8" title="1">data["attributes"] = span.Attributes

                // Add span events
                if len(span.Events) &gt; 0 </span><span class="cov8" title="1">{
                        events := make([]map[string]interface{}, len(span.Events))
                        for i, event := range span.Events </span><span class="cov8" title="1">{
                                events[i] = map[string]interface{}{
                                        "name":       event.Name,
                                        "timestamp":  event.Timestamp,
                                        "attributes": event.Attributes,
                                }
                        }</span>
                        <span class="cov8" title="1">data["events"] = events</span>
                }
        }

        // Add trace data if available
        <span class="cov8" title="1">if context.TraceData != nil </span><span class="cov8" title="1">{
                traceData := context.TraceData
                data["trace"] = map[string]interface{}{
                        "id":         traceData.TraceID,
                        "span_count": len(traceData.Spans),
                }

                if traceData.RootSpan != nil </span><span class="cov8" title="1">{
                        data["trace"].(map[string]interface{})["root_span"] = map[string]interface{}{
                                "id":   traceData.RootSpan.SpanID,
                                "name": traceData.RootSpan.Name,
                        }
                }</span>
        }

        // Add context variables
        <span class="cov8" title="1">allVars := context.GetAllVariables()
        for key, value := range allVars </span><span class="cov8" title="1">{
                // Avoid overwriting existing keys, use "vars" namespace
                if _, exists := data[key]; !exists </span><span class="cov8" title="1">{
                        data[key] = value
                }</span>
        }

        // Add variables under "vars" namespace as well
        <span class="cov8" title="1">data["vars"] = allVars

        // Add evaluation metadata
        data["_meta"] = map[string]interface{}{
                "timestamp":    context.Timestamp,
                "evaluator":    "jsonlogic",
                "version":      "1.0",
                "strict_mode":  evaluator.config.StrictMode,
                "sandbox_mode": evaluator.config.SandboxMode,
        }

        return data, nil</span>
}

// applyWithTimeout applies JSONLogic with timeout protection
func (evaluator *JSONLogicEvaluator) applyWithTimeout(rule interface{}, data interface{}) (interface{}, error) <span class="cov8" title="1">{
        if evaluator.config.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                // No timeout, apply directly
                return jsonlogic.ApplyInterface(rule, data)
        }</span>

        // Use channel to implement timeout
        <span class="cov8" title="1">resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("JSONLogic evaluation panicked: %v", r)
                        }</span>
                }()

                <span class="cov8" title="1">result, err := jsonlogic.ApplyInterface(rule, data)
                if err != nil </span><span class="cov8" title="1">{
                        errorChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- result
                }</span>
        }()

        <span class="cov8" title="1">select </span>{
        case result := &lt;-resultChan:<span class="cov8" title="1">
                return result, nil</span>
        case err := &lt;-errorChan:<span class="cov8" title="1">
                return nil, err</span>
        case &lt;-time.After(evaluator.config.Timeout):<span class="cov0" title="0">
                return nil, fmt.Errorf("JSONLogic evaluation timed out after %v", evaluator.config.Timeout)</span>
        }
}

// convertToBool converts JSONLogic result to boolean
func (evaluator *JSONLogicEvaluator) convertToBool(result interface{}) bool <span class="cov8" title="1">{
        if result == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch v := result.(type) </span>{
        case bool:<span class="cov8" title="1">
                return v</span>
        case int:<span class="cov8" title="1">
                return v != 0</span>
        case int64:<span class="cov8" title="1">
                return v != 0</span>
        case float64:<span class="cov8" title="1">
                return v != 0.0</span>
        case string:<span class="cov8" title="1">
                return v != ""</span>
        case []interface{}:<span class="cov8" title="1">
                return len(v) &gt; 0</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return len(v) &gt; 0</span>
        default:<span class="cov0" title="0">
                // Use reflection for other types
                rv := reflect.ValueOf(result)
                switch rv.Kind() </span>{
                case reflect.Bool:<span class="cov0" title="0">
                        return rv.Bool()</span>
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        return rv.Int() != 0</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        return rv.Uint() != 0</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        return rv.Float() != 0.0</span>
                case reflect.String:<span class="cov0" title="0">
                        return rv.String() != ""</span>
                case reflect.Slice, reflect.Array, reflect.Map:<span class="cov0" title="0">
                        return rv.Len() &gt; 0</span>
                case reflect.Ptr, reflect.Interface:<span class="cov0" title="0">
                        return !rv.IsNil()</span>
                default:<span class="cov0" title="0">
                        return true</span> // Non-zero values are truthy
                }
        }
}

// buildResultMessage builds a descriptive message for the assertion result
func (evaluator *JSONLogicEvaluator) buildResultMessage(passed bool, assertion map[string]interface{}, result interface{}) string <span class="cov8" title="1">{
        if passed </span><span class="cov8" title="1">{
                return fmt.Sprintf("Assertion passed: %v evaluated to %v", assertion, result)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("Assertion failed: %v evaluated to %v (expected truthy value)", assertion, result)
        }</span>
}

// validateOperators validates that only allowed operators are used
func (evaluator *JSONLogicEvaluator) validateOperators(assertion map[string]interface{}, allowedOps []string) error <span class="cov8" title="1">{
        allowedSet := make(map[string]bool)
        for _, op := range allowedOps </span><span class="cov8" title="1">{
                allowedSet[op] = true
        }</span>

        <span class="cov8" title="1">return evaluator.validateOperatorsRecursive(assertion, allowedSet)</span>
}

// validateOperatorsRecursive recursively validates operators
func (evaluator *JSONLogicEvaluator) validateOperatorsRecursive(obj interface{}, allowedOps map[string]bool) error <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        // Check if key is an operator
                        if strings.Contains(key, ".") || len(allowedOps) &gt; 0 </span><span class="cov8" title="1">{
                                if !allowedOps[key] </span><span class="cov8" title="1">{
                                        return fmt.Errorf("operator '%s' is not allowed", key)
                                }</span>
                        }
                        
                        // Recursively validate nested objects
                        <span class="cov8" title="1">if err := evaluator.validateOperatorsRecursive(value, allowedOps); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateOperatorsRecursive(item, allowedOps); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return nil</span>
}

// validateDepth validates that the assertion doesn't exceed maximum depth
func (evaluator *JSONLogicEvaluator) validateDepth(obj interface{}, currentDepth, maxDepth int) error <span class="cov8" title="1">{
        if currentDepth &gt; maxDepth </span><span class="cov8" title="1">{
                return fmt.Errorf("assertion exceeds maximum depth of %d", maxDepth)
        }</span>

        <span class="cov8" title="1">switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for _, value := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateDepth(value, currentDepth+1, maxDepth); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateDepth(item, currentDepth+1, maxDepth); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConfig returns the current configuration
func (evaluator *JSONLogicEvaluator) GetConfig() *JSONLogicConfig <span class="cov8" title="1">{
        return evaluator.config
}</span>

// SetConfig updates the configuration
func (evaluator *JSONLogicEvaluator) SetConfig(config *JSONLogicConfig) <span class="cov8" title="1">{
        evaluator.config = config
}</span>

// ValidateConfig validates the JSONLogic configuration
func ValidateJSONLogicConfig(config *JSONLogicConfig) error <span class="cov8" title="1">{
        if config.MaxDepth &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxDepth must be positive, got %d", config.MaxDepth)
        }</span>

        <span class="cov8" title="1">if config.Timeout &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Timeout cannot be negative, got %s", config.Timeout)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package ingestor

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "runtime"
        "sync"
        "time"

        "flowspec-cli/internal/models"
)

// TraceIngestor defines the interface for ingesting OpenTelemetry traces
type TraceIngestor interface {
        IngestFromFile(filePath string) (*models.TraceData, error)
        IngestFromReader(reader io.Reader) (*models.TraceData, error)
        SetMemoryLimit(limitMB int64)
        GetMemoryUsage() int64
}

// TraceQuery defines the interface for querying trace data
type TraceQuery interface {
        FindSpanByID(spanID string) *models.Span
        FindSpansByName(name string) []*models.Span
        FindSpansByOperationID(operationID string) []*models.Span
        GetRootSpan() *models.Span
        GetAllSpans() []*models.Span
}

// TraceStore provides storage and querying capabilities for trace data
type TraceStore struct {
        traceData    *models.TraceData
        spanIndex    map[string]*models.Span           // spanID -&gt; Span
        nameIndex    map[string][]*models.Span         // span name -&gt; Spans
        operationIndex map[string][]*models.Span       // operation ID -&gt; Spans
        mu           sync.RWMutex
}

// DefaultTraceIngestor implements the TraceIngestor interface
type DefaultTraceIngestor struct {
        memoryLimit   int64 // Memory limit in bytes
        currentMemory int64 // Current memory usage estimate
        mu            sync.RWMutex
}

// IngestorConfig holds configuration for the trace ingestor
type IngestorConfig struct {
        MemoryLimitMB    int64 // Memory limit in MB
        EnableStreaming  bool  // Enable streaming for large files
        ChunkSize        int   // Chunk size for streaming
        MaxFileSize      int64 // Maximum file size in bytes
        EnableMetrics    bool  // Enable performance metrics
}

// IngestMetrics tracks ingestion performance
type IngestMetrics struct {
        StartTime       time.Time
        EndTime         time.Time
        TotalSpans      int
        ProcessedSpans  int
        MemoryUsed      int64
        FileSize        int64
        ProcessingTime  time.Duration
        mu              sync.RWMutex
}

// OTLPTrace represents the root structure of an OTLP JSON trace
type OTLPTrace struct {
        ResourceSpans []ResourceSpan `json:"resourceSpans"`
}

// ResourceSpan represents a resource span in OTLP format
type ResourceSpan struct {
        Resource    Resource    `json:"resource"`
        ScopeSpans  []ScopeSpan `json:"scopeSpans"`
}

// Resource represents a resource in OTLP format
type Resource struct {
        Attributes []Attribute `json:"attributes"`
}

// ScopeSpan represents a scope span in OTLP format
type ScopeSpan struct {
        Scope Scope       `json:"scope"`
        Spans []OTLPSpan  `json:"spans"`
}

// Scope represents a scope in OTLP format
type Scope struct {
        Name    string `json:"name"`
        Version string `json:"version"`
}

// OTLPSpan represents a span in OTLP JSON format
type OTLPSpan struct {
        TraceID           string      `json:"traceId"`
        SpanID            string      `json:"spanId"`
        ParentSpanID      string      `json:"parentSpanId,omitempty"`
        Name              string      `json:"name"`
        Kind              int         `json:"kind"`
        StartTimeUnixNano string      `json:"startTimeUnixNano"`
        EndTimeUnixNano   string      `json:"endTimeUnixNano"`
        Attributes        []Attribute `json:"attributes"`
        Status            Status      `json:"status"`
        Events            []Event     `json:"events"`
}

// Attribute represents an attribute in OTLP format
type Attribute struct {
        Key   string      `json:"key"`
        Value interface{} `json:"value"`
}

// Status represents span status in OTLP format
type Status struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// Event represents a span event in OTLP format
type Event struct {
        TimeUnixNano string      `json:"timeUnixNano"`
        Name         string      `json:"name"`
        Attributes   []Attribute `json:"attributes"`
}

// DefaultIngestorConfig returns a default ingestor configuration
func DefaultIngestorConfig() *IngestorConfig <span class="cov8" title="1">{
        return &amp;IngestorConfig{
                MemoryLimitMB:   500, // 500MB default limit
                EnableStreaming: true,
                ChunkSize:       1024 * 1024, // 1MB chunks
                MaxFileSize:     100 * 1024 * 1024, // 100MB max file size
                EnableMetrics:   true,
        }
}</span>

// NewTraceIngestor creates a new trace ingestor with default configuration
func NewTraceIngestor() *DefaultTraceIngestor <span class="cov8" title="1">{
        config := DefaultIngestorConfig()
        return &amp;DefaultTraceIngestor{
                memoryLimit: config.MemoryLimitMB * 1024 * 1024, // Convert to bytes
        }
}</span>

// NewTraceIngestorWithConfig creates a new trace ingestor with custom configuration
func NewTraceIngestorWithConfig(config *IngestorConfig) *DefaultTraceIngestor <span class="cov8" title="1">{
        return &amp;DefaultTraceIngestor{
                memoryLimit: config.MemoryLimitMB * 1024 * 1024, // Convert to bytes
        }
}</span>

// NewTraceStore creates a new trace store
func NewTraceStore() *TraceStore <span class="cov8" title="1">{
        return &amp;TraceStore{
                spanIndex:      make(map[string]*models.Span),
                nameIndex:      make(map[string][]*models.Span),
                operationIndex: make(map[string][]*models.Span),
        }
}</span>

// NewIngestMetrics creates a new ingest metrics tracker
func NewIngestMetrics() *IngestMetrics <span class="cov8" title="1">{
        return &amp;IngestMetrics{
                StartTime: time.Now(),
        }
}</span>

// IngestFromFile implements the TraceIngestor interface
func (ti *DefaultTraceIngestor) IngestFromFile(filePath string) (*models.TraceData, error) <span class="cov8" title="1">{
        // Check if file exists and get size
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to access file %s: %w", filePath, err)
        }</span>
        
        // Check file size limits
        <span class="cov8" title="1">if fileInfo.Size() &gt; 100*1024*1024 </span><span class="cov8" title="1">{ // 100MB limit
                return nil, fmt.Errorf("file size %d bytes exceeds maximum limit of 100MB", fileInfo.Size())
        }</span>
        
        // Open file
        <span class="cov8" title="1">file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open file %s: %w", filePath, err)
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // Ingest from reader
        return ti.IngestFromReader(file)</span>
}

// IngestFromReader implements the TraceIngestor interface
func (ti *DefaultTraceIngestor) IngestFromReader(reader io.Reader) (*models.TraceData, error) <span class="cov8" title="1">{
        metrics := NewIngestMetrics()
        defer metrics.Finish()
        
        // Check memory before starting
        if err := ti.checkMemoryLimit(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Read and parse JSON
        <span class="cov8" title="1">data, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read trace data: %w", err)
        }</span>
        
        // Update memory usage estimate
        <span class="cov8" title="1">ti.updateMemoryUsage(int64(len(data)))
        metrics.FileSize = int64(len(data))
        
        // Parse OTLP JSON
        var otlpTrace OTLPTrace
        if err := json.Unmarshal(data, &amp;otlpTrace); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse OTLP JSON: %w", err)
        }</span>
        
        // Convert to internal format
        <span class="cov8" title="1">traceData, err := ti.convertOTLPToTraceData(otlpTrace, metrics)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to convert OTLP data: %w", err)
        }</span>
        
        // Build span tree
        <span class="cov8" title="1">if err := traceData.BuildSpanTree(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build span tree: %w", err)
        }</span>
        
        <span class="cov8" title="1">metrics.ProcessedSpans = len(traceData.Spans)
        metrics.MemoryUsed = ti.GetMemoryUsage()
        
        return traceData, nil</span>
}

// SetMemoryLimit implements the TraceIngestor interface
func (ti *DefaultTraceIngestor) SetMemoryLimit(limitMB int64) <span class="cov8" title="1">{
        ti.mu.Lock()
        defer ti.mu.Unlock()
        ti.memoryLimit = limitMB * 1024 * 1024 // Convert to bytes
}</span>

// GetMemoryUsage implements the TraceIngestor interface
func (ti *DefaultTraceIngestor) GetMemoryUsage() int64 <span class="cov8" title="1">{
        ti.mu.RLock()
        defer ti.mu.RUnlock()
        return ti.currentMemory
}</span>

// checkMemoryLimit checks if current memory usage is within limits
func (ti *DefaultTraceIngestor) checkMemoryLimit() error <span class="cov8" title="1">{
        ti.mu.RLock()
        defer ti.mu.RUnlock()
        
        // Get current system memory usage
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        if int64(m.Alloc) &gt; ti.memoryLimit </span><span class="cov0" title="0">{
                return fmt.Errorf("memory usage %d bytes exceeds limit %d bytes", m.Alloc, ti.memoryLimit)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// updateMemoryUsage updates the current memory usage estimate
func (ti *DefaultTraceIngestor) updateMemoryUsage(additionalBytes int64) <span class="cov8" title="1">{
        ti.mu.Lock()
        defer ti.mu.Unlock()
        ti.currentMemory += additionalBytes
}</span>

// convertOTLPToTraceData converts OTLP format to internal TraceData format
func (ti *DefaultTraceIngestor) convertOTLPToTraceData(otlpTrace OTLPTrace, metrics *IngestMetrics) (*models.TraceData, error) <span class="cov8" title="1">{
        if len(otlpTrace.ResourceSpans) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no resource spans found in trace data")
        }</span>
        
        <span class="cov8" title="1">traceData := &amp;models.TraceData{
                Spans: make(map[string]*models.Span),
        }
        
        // Process all resource spans
        for _, resourceSpan := range otlpTrace.ResourceSpans </span><span class="cov8" title="1">{
                for _, scopeSpan := range resourceSpan.ScopeSpans </span><span class="cov8" title="1">{
                        for _, otlpSpan := range scopeSpan.Spans </span><span class="cov8" title="1">{
                                span, err := ti.convertOTLPSpan(otlpSpan)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("failed to convert span %s: %w", otlpSpan.SpanID, err)
                                }</span>
                                
                                // Set trace ID if not set
                                <span class="cov8" title="1">if traceData.TraceID == "" </span><span class="cov8" title="1">{
                                        traceData.TraceID = span.TraceID
                                }</span>
                                
                                // Add to spans map
                                <span class="cov8" title="1">traceData.Spans[span.SpanID] = span
                                metrics.TotalSpans++</span>
                        }
                }
        }
        
        <span class="cov8" title="1">if len(traceData.Spans) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no spans found in trace data")
        }</span>
        
        <span class="cov8" title="1">return traceData, nil</span>
}

// convertOTLPSpan converts an OTLP span to internal Span format
func (ti *DefaultTraceIngestor) convertOTLPSpan(otlpSpan OTLPSpan) (*models.Span, error) <span class="cov8" title="1">{
        // Parse timestamps
        startTime, err := parseNanoTimestamp(otlpSpan.StartTimeUnixNano)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid start time: %w", err)
        }</span>
        
        <span class="cov8" title="1">endTime, err := parseNanoTimestamp(otlpSpan.EndTimeUnixNano)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid end time: %w", err)
        }</span>
        
        // Convert attributes
        <span class="cov8" title="1">attributes := make(map[string]interface{})
        for _, attr := range otlpSpan.Attributes </span><span class="cov8" title="1">{
                attributes[attr.Key] = attr.Value
        }</span>
        
        // Convert status
        <span class="cov8" title="1">status := models.SpanStatus{
                Code:    convertStatusCode(otlpSpan.Status.Code),
                Message: otlpSpan.Status.Message,
        }
        
        // Convert events
        var events []models.SpanEvent
        for _, event := range otlpSpan.Events </span><span class="cov8" title="1">{
                eventTime, err := parseNanoTimestamp(event.TimeUnixNano)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid events
                }
                
                <span class="cov8" title="1">eventAttrs := make(map[string]interface{})
                for _, attr := range event.Attributes </span><span class="cov8" title="1">{
                        eventAttrs[attr.Key] = attr.Value
                }</span>
                
                <span class="cov8" title="1">events = append(events, models.SpanEvent{
                        Name:       event.Name,
                        Timestamp:  eventTime,
                        Attributes: eventAttrs,
                })</span>
        }
        
        <span class="cov8" title="1">span := &amp;models.Span{
                SpanID:     otlpSpan.SpanID,
                TraceID:    otlpSpan.TraceID,
                ParentID:   otlpSpan.ParentSpanID,
                Name:       otlpSpan.Name,
                StartTime:  startTime,
                EndTime:    endTime,
                Status:     status,
                Attributes: attributes,
                Events:     events,
        }
        
        return span, nil</span>
}

// parseNanoTimestamp parses a nanosecond timestamp string
func parseNanoTimestamp(timestampStr string) (int64, error) <span class="cov8" title="1">{
        if timestampStr == "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("empty timestamp")
        }</span>
        
        // Try to parse as int64 directly (nanoseconds since epoch)
        <span class="cov8" title="1">var timestamp int64
        n, err := fmt.Sscanf(timestampStr, "%d", &amp;timestamp)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to parse timestamp %s: %w", timestampStr, err)
        }</span>
        <span class="cov8" title="1">if n != 1 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse timestamp %s: invalid format", timestampStr)
        }</span>
        
        // Validate that the entire string was consumed (no extra characters)
        <span class="cov8" title="1">var extra string
        if _, err := fmt.Sscanf(timestampStr, "%d%s", &amp;timestamp, &amp;extra); err == nil &amp;&amp; extra != "" </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to parse timestamp %s: contains non-numeric characters", timestampStr)
        }</span>
        
        <span class="cov8" title="1">return timestamp, nil</span>
}

// convertStatusCode converts OTLP status code to string
func convertStatusCode(code int) string <span class="cov8" title="1">{
        switch code </span>{
        case 0:<span class="cov8" title="1">
                return "UNSET"</span>
        case 1:<span class="cov8" title="1">
                return "OK"</span>
        case 2:<span class="cov8" title="1">
                return "ERROR"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// TraceStore methods

// SetTraceData sets the trace data for the store
func (ts *TraceStore) SetTraceData(traceData *models.TraceData) <span class="cov8" title="1">{
        ts.mu.Lock()
        defer ts.mu.Unlock()
        
        ts.traceData = traceData
        ts.buildIndexes()
}</span>

// buildIndexes builds search indexes for efficient querying
func (ts *TraceStore) buildIndexes() <span class="cov8" title="1">{
        // Clear existing indexes
        ts.spanIndex = make(map[string]*models.Span)
        ts.nameIndex = make(map[string][]*models.Span)
        ts.operationIndex = make(map[string][]*models.Span)
        
        if ts.traceData == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        // Build indexes
        <span class="cov8" title="1">for spanID, span := range ts.traceData.Spans </span><span class="cov8" title="1">{
                // Span ID index
                ts.spanIndex[spanID] = span
                
                // Name index
                ts.nameIndex[span.Name] = append(ts.nameIndex[span.Name], span)
                
                // Operation ID index (from attributes)
                if operationID, ok := span.Attributes["operation.id"].(string); ok </span><span class="cov8" title="1">{
                        ts.operationIndex[operationID] = append(ts.operationIndex[operationID], span)
                }</span>
        }
}

// FindSpanByID implements the TraceQuery interface
func (ts *TraceStore) FindSpanByID(spanID string) *models.Span <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.spanIndex[spanID]
}</span>

// FindSpansByName implements the TraceQuery interface
func (ts *TraceStore) FindSpansByName(name string) []*models.Span <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.nameIndex[name]
}</span>

// FindSpansByOperationID implements the TraceQuery interface
func (ts *TraceStore) FindSpansByOperationID(operationID string) []*models.Span <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.operationIndex[operationID]
}</span>

// GetRootSpan implements the TraceQuery interface
func (ts *TraceStore) GetRootSpan() *models.Span <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        
        if ts.traceData != nil </span><span class="cov8" title="1">{
                return ts.traceData.RootSpan
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetAllSpans implements the TraceQuery interface
func (ts *TraceStore) GetAllSpans() []*models.Span <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        
        if ts.traceData == nil </span><span class="cov8" title="1">{
                return []*models.Span{}
        }</span>
        
        <span class="cov8" title="1">spans := make([]*models.Span, 0, len(ts.traceData.Spans))
        for _, span := range ts.traceData.Spans </span><span class="cov8" title="1">{
                spans = append(spans, span)
        }</span>
        <span class="cov8" title="1">return spans</span>
}

// GetTraceData returns the underlying trace data
func (ts *TraceStore) GetTraceData() *models.TraceData <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        return ts.traceData
}</span>

// GetSpanCount returns the number of spans in the store
func (ts *TraceStore) GetSpanCount() int <span class="cov8" title="1">{
        ts.mu.RLock()
        defer ts.mu.RUnlock()
        
        if ts.traceData == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return len(ts.traceData.Spans)</span>
}

// IngestMetrics methods

// Finish marks the ingestion as finished and calculates final metrics
func (im *IngestMetrics) Finish() <span class="cov8" title="1">{
        im.mu.Lock()
        defer im.mu.Unlock()
        im.EndTime = time.Now()
        im.ProcessingTime = im.EndTime.Sub(im.StartTime)
}</span>

// GetSummary returns a summary of ingestion metrics
func (im *IngestMetrics) GetSummary() map[string]interface{} <span class="cov8" title="1">{
        im.mu.RLock()
        defer im.mu.RUnlock()
        
        return map[string]interface{}{
                "total_spans":      im.TotalSpans,
                "processed_spans":  im.ProcessedSpans,
                "memory_used":      im.MemoryUsed,
                "file_size":        im.FileSize,
                "processing_time":  im.ProcessingTime.String(),
                "spans_per_second": float64(im.ProcessedSpans) / im.ProcessingTime.Seconds(),
        }
}</span>

// GetProcessingRate returns the processing rate in spans per second
func (im *IngestMetrics) GetProcessingRate() float64 <span class="cov8" title="1">{
        im.mu.RLock()
        defer im.mu.RUnlock()
        
        if im.ProcessingTime.Seconds() == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(im.ProcessedSpans) / im.ProcessingTime.Seconds()</span>
}</pre>
		
		<pre class="file" id="file3" style="display: none">package ingestor

import (
        "bufio"
        "encoding/json"
        "fmt"
        "io"
        "runtime"
        "sync"
        "time"

        "flowspec-cli/internal/models"
)

// StreamingIngestor provides streaming ingestion capabilities for large trace files
type StreamingIngestor struct {
        *DefaultTraceIngestor
        chunkSize       int
        maxMemoryUsage  int64
        progressCallback func(processed, total int64)
        mu              sync.RWMutex
}

// StreamingConfig holds configuration for streaming ingestion
type StreamingConfig struct {
        ChunkSize        int                           // Size of each processing chunk
        MaxMemoryUsage   int64                         // Maximum memory usage in bytes
        ProgressCallback func(processed, total int64) // Progress callback function
        EnableGC         bool                          // Enable aggressive garbage collection
        GCInterval       time.Duration                 // Interval for garbage collection
}

// ChunkProcessor processes individual chunks of trace data
type ChunkProcessor struct {
        spans       []*models.Span
        errors      []error
        memoryUsed  int64
        mu          sync.Mutex
}

// MemoryMonitor monitors and controls memory usage during ingestion
type MemoryMonitor struct {
        maxMemory     int64
        currentMemory int64
        gcThreshold   float64 // Trigger GC when memory usage exceeds this percentage
        mu            sync.RWMutex
}

// ProgressTracker tracks ingestion progress
type ProgressTracker struct {
        totalBytes     int64
        processedBytes int64
        startTime      time.Time
        callback       func(processed, total int64)
        mu             sync.RWMutex
}

// DefaultStreamingConfig returns a default streaming configuration
func DefaultStreamingConfig() *StreamingConfig <span class="cov8" title="1">{
        return &amp;StreamingConfig{
                ChunkSize:      1024 * 1024, // 1MB chunks
                MaxMemoryUsage: 500 * 1024 * 1024, // 500MB max memory
                EnableGC:       true,
                GCInterval:     5 * time.Second,
        }
}</span>

// NewStreamingIngestor creates a new streaming ingestor
func NewStreamingIngestor(config *StreamingConfig) *StreamingIngestor <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultStreamingConfig()
        }</span>
        
        <span class="cov8" title="1">baseIngestor := NewTraceIngestor()
        baseIngestor.SetMemoryLimit(config.MaxMemoryUsage / (1024 * 1024)) // Convert to MB
        
        return &amp;StreamingIngestor{
                DefaultTraceIngestor: baseIngestor,
                chunkSize:            config.ChunkSize,
                maxMemoryUsage:       config.MaxMemoryUsage,
                progressCallback:     config.ProgressCallback,
        }</span>
}

// NewMemoryMonitor creates a new memory monitor
func NewMemoryMonitor(maxMemory int64) *MemoryMonitor <span class="cov8" title="1">{
        return &amp;MemoryMonitor{
                maxMemory:   maxMemory,
                gcThreshold: 0.8, // Trigger GC at 80% memory usage
        }
}</span>

// NewProgressTracker creates a new progress tracker
func NewProgressTracker(totalBytes int64, callback func(processed, total int64)) *ProgressTracker <span class="cov8" title="1">{
        return &amp;ProgressTracker{
                totalBytes: totalBytes,
                startTime:  time.Now(),
                callback:   callback,
        }
}</span>

// IngestFromReaderStreaming ingests trace data using streaming approach
func (si *StreamingIngestor) IngestFromReaderStreaming(reader io.Reader, totalSize int64) (*models.TraceData, error) <span class="cov8" title="1">{
        // Initialize memory monitor
        monitor := NewMemoryMonitor(si.maxMemoryUsage)
        
        // Initialize progress tracker
        var tracker *ProgressTracker
        if si.progressCallback != nil </span><span class="cov8" title="1">{
                tracker = NewProgressTracker(totalSize, si.progressCallback)
        }</span>
        
        // Start memory monitoring goroutine
        <span class="cov8" title="1">stopMonitoring := make(chan bool)
        go si.monitorMemory(monitor, stopMonitoring)
        defer func() </span><span class="cov8" title="1">{ stopMonitoring &lt;- true }</span>()
        
        // Process in chunks
        <span class="cov8" title="1">traceData, err := si.processInChunks(reader, monitor, tracker)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        
        // Build span tree
        <span class="cov8" title="1">if err := traceData.BuildSpanTree(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build span tree: %w", err)
        }</span>
        
        <span class="cov8" title="1">return traceData, nil</span>
}

// processInChunks processes the input stream in manageable chunks
func (si *StreamingIngestor) processInChunks(reader io.Reader, monitor *MemoryMonitor, tracker *ProgressTracker) (*models.TraceData, error) <span class="cov8" title="1">{
        // Use a buffered reader for efficient reading
        bufferedReader := bufio.NewReaderSize(reader, si.chunkSize)
        
        // Read the entire JSON structure first to understand the format
        // For OTLP JSON, we need to parse the complete structure
        data, err := io.ReadAll(bufferedReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read trace data: %w", err)
        }</span>
        
        // Update progress
        <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                tracker.UpdateProgress(int64(len(data)))
        }</span>
        
        // Check memory usage before processing
        <span class="cov8" title="1">if err := monitor.CheckMemoryLimit(int64(len(data))); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Parse JSON in chunks if possible, otherwise parse normally
        <span class="cov8" title="1">if len(data) &gt; si.chunkSize*2 </span><span class="cov8" title="1">{ // Use chunked processing for files larger than 2x chunk size
                return si.parseJSONInChunks(data, monitor, tracker)
        }</span>
        
        // For smaller files, use normal parsing
        <span class="cov8" title="1">return si.parseJSONNormally(data, monitor)</span>
}

// parseJSONInChunks attempts to parse large JSON files in chunks
func (si *StreamingIngestor) parseJSONInChunks(data []byte, monitor *MemoryMonitor, tracker *ProgressTracker) (*models.TraceData, error) <span class="cov8" title="1">{
        // For OTLP JSON format, we need to parse the complete structure
        // Chunked JSON parsing is complex, so we'll use memory-efficient parsing instead
        return si.parseJSONWithMemoryOptimization(data, monitor, tracker)
}</span>

// parseJSONWithMemoryOptimization parses JSON with memory optimization techniques
func (si *StreamingIngestor) parseJSONWithMemoryOptimization(data []byte, monitor *MemoryMonitor, tracker *ProgressTracker) (*models.TraceData, error) <span class="cov8" title="1">{
        // Parse OTLP structure
        var otlpTrace OTLPTrace
        if err := json.Unmarshal(data, &amp;otlpTrace); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse OTLP JSON: %w", err)
        }</span>
        
        // Process resource spans one by one to minimize memory usage
        <span class="cov8" title="1">traceData := &amp;models.TraceData{
                Spans: make(map[string]*models.Span),
        }
        
        totalResourceSpans := len(otlpTrace.ResourceSpans)
        processedResourceSpans := 0
        
        for _, resourceSpan := range otlpTrace.ResourceSpans </span><span class="cov8" title="1">{
                // Check memory before processing each resource span
                if err := monitor.CheckMemoryLimit(0); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                
                // Process scope spans
                <span class="cov8" title="1">for _, scopeSpan := range resourceSpan.ScopeSpans </span><span class="cov8" title="1">{
                        // Process spans in batches
                        batchSize := 100 // Process 100 spans at a time
                        for i := 0; i &lt; len(scopeSpan.Spans); i += batchSize </span><span class="cov8" title="1">{
                                end := i + batchSize
                                if end &gt; len(scopeSpan.Spans) </span><span class="cov8" title="1">{
                                        end = len(scopeSpan.Spans)
                                }</span>
                                
                                // Process batch
                                <span class="cov8" title="1">batch := scopeSpan.Spans[i:end]
                                if err := si.processBatch(batch, traceData, monitor); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                
                                // Update progress
                                <span class="cov8" title="1">if tracker != nil </span><span class="cov8" title="1">{
                                        progress := float64(processedResourceSpans)/float64(totalResourceSpans) + 
                                                float64(end)/float64(len(scopeSpan.Spans))/float64(totalResourceSpans)
                                        tracker.UpdateProgressPercent(progress)
                                }</span>
                                
                                // Force garbage collection periodically
                                <span class="cov8" title="1">if i%500 == 0 </span><span class="cov8" title="1">{
                                        runtime.GC()
                                }</span>
                        }
                }
                
                <span class="cov8" title="1">processedResourceSpans++</span>
        }
        
        <span class="cov8" title="1">return traceData, nil</span>
}

// parseJSONNormally parses JSON using the normal approach for smaller files
func (si *StreamingIngestor) parseJSONNormally(data []byte, monitor *MemoryMonitor) (*models.TraceData, error) <span class="cov8" title="1">{
        // Check memory before parsing
        if err := monitor.CheckMemoryLimit(int64(len(data))); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Parse OTLP JSON
        <span class="cov8" title="1">var otlpTrace OTLPTrace
        if err := json.Unmarshal(data, &amp;otlpTrace); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse OTLP JSON: %w", err)
        }</span>
        
        // Convert to internal format
        <span class="cov8" title="1">metrics := NewIngestMetrics()
        traceData, err := si.convertOTLPToTraceData(otlpTrace, metrics)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to convert OTLP data: %w", err)
        }</span>
        
        <span class="cov8" title="1">return traceData, nil</span>
}

// processBatch processes a batch of OTLP spans
func (si *StreamingIngestor) processBatch(batch []OTLPSpan, traceData *models.TraceData, monitor *MemoryMonitor) error <span class="cov8" title="1">{
        for _, otlpSpan := range batch </span><span class="cov8" title="1">{
                // Convert span
                span, err := si.convertOTLPSpan(otlpSpan)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid spans
                }
                
                // Set trace ID if not set
                <span class="cov8" title="1">if traceData.TraceID == "" </span><span class="cov8" title="1">{
                        traceData.TraceID = span.TraceID
                }</span>
                
                // Add to spans map
                <span class="cov8" title="1">traceData.Spans[span.SpanID] = span
                
                // Check memory usage periodically
                if len(traceData.Spans)%100 == 0 </span><span class="cov8" title="1">{
                        if err := monitor.CheckMemoryLimit(0); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return nil</span>
}

// monitorMemory monitors memory usage in a separate goroutine
func (si *StreamingIngestor) monitorMemory(monitor *MemoryMonitor, stop &lt;-chan bool) <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-stop:<span class="cov8" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        monitor.UpdateMemoryUsage()
                        
                        // Trigger GC if memory usage is high
                        if monitor.ShouldTriggerGC() </span><span class="cov0" title="0">{
                                runtime.GC()
                        }</span>
                }
        }
}

// MemoryMonitor methods

// CheckMemoryLimit checks if adding the specified bytes would exceed memory limit
func (mm *MemoryMonitor) CheckMemoryLimit(additionalBytes int64) error <span class="cov8" title="1">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()
        
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        currentUsage := int64(m.Alloc)
        if currentUsage+additionalBytes &gt; mm.maxMemory </span><span class="cov8" title="1">{
                return fmt.Errorf("memory usage would exceed limit: current=%d, additional=%d, limit=%d", 
                        currentUsage, additionalBytes, mm.maxMemory)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// UpdateMemoryUsage updates the current memory usage
func (mm *MemoryMonitor) UpdateMemoryUsage() <span class="cov8" title="1">{
        mm.mu.Lock()
        defer mm.mu.Unlock()
        
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        mm.currentMemory = int64(m.Alloc)
}</span>

// ShouldTriggerGC returns true if garbage collection should be triggered
func (mm *MemoryMonitor) ShouldTriggerGC() bool <span class="cov0" title="0">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()
        
        return float64(mm.currentMemory)/float64(mm.maxMemory) &gt; mm.gcThreshold
}</span>

// GetMemoryUsage returns current memory usage
func (mm *MemoryMonitor) GetMemoryUsage() int64 <span class="cov8" title="1">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()
        return mm.currentMemory
}</span>

// GetMemoryUsagePercent returns current memory usage as percentage
func (mm *MemoryMonitor) GetMemoryUsagePercent() float64 <span class="cov8" title="1">{
        mm.mu.RLock()
        defer mm.mu.RUnlock()
        return float64(mm.currentMemory) / float64(mm.maxMemory) * 100
}</span>

// ProgressTracker methods

// UpdateProgress updates the progress with processed bytes
func (pt *ProgressTracker) UpdateProgress(processedBytes int64) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()
        
        pt.processedBytes = processedBytes
        
        if pt.callback != nil </span><span class="cov8" title="1">{
                pt.callback(pt.processedBytes, pt.totalBytes)
        }</span>
}

// UpdateProgressPercent updates progress with a percentage (0.0 to 1.0)
func (pt *ProgressTracker) UpdateProgressPercent(percent float64) <span class="cov8" title="1">{
        pt.mu.Lock()
        defer pt.mu.Unlock()
        
        pt.processedBytes = int64(float64(pt.totalBytes) * percent)
        
        if pt.callback != nil </span><span class="cov8" title="1">{
                pt.callback(pt.processedBytes, pt.totalBytes)
        }</span>
}

// GetProgress returns current progress information
func (pt *ProgressTracker) GetProgress() (processed, total int64, percent float64, elapsed time.Duration) <span class="cov8" title="1">{
        pt.mu.RLock()
        defer pt.mu.RUnlock()
        
        processed = pt.processedBytes
        total = pt.totalBytes
        if total &gt; 0 </span><span class="cov8" title="1">{
                percent = float64(processed) / float64(total) * 100
        }</span>
        <span class="cov8" title="1">elapsed = time.Since(pt.startTime)
        
        return</span>
}

// GetETA returns estimated time of arrival
func (pt *ProgressTracker) GetETA() time.Duration <span class="cov8" title="1">{
        processed, total, _, elapsed := pt.GetProgress()
        
        if processed == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        
        <span class="cov8" title="1">rate := float64(processed) / elapsed.Seconds()
        remaining := total - processed
        
        if rate &gt; 0 </span><span class="cov8" title="1">{
                return time.Duration(float64(remaining)/rate) * time.Second
        }</span>
        
        <span class="cov0" title="0">return 0</span>
}

// ChunkProcessor methods

// NewChunkProcessor creates a new chunk processor
func NewChunkProcessor() *ChunkProcessor <span class="cov8" title="1">{
        return &amp;ChunkProcessor{
                spans:  make([]*models.Span, 0),
                errors: make([]error, 0),
        }
}</span>

// AddSpan adds a span to the processor
func (cp *ChunkProcessor) AddSpan(span *models.Span) <span class="cov8" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()
        
        cp.spans = append(cp.spans, span)
        cp.memoryUsed += cp.estimateSpanMemory(span)
}</span>

// AddError adds an error to the processor
func (cp *ChunkProcessor) AddError(err error) <span class="cov8" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()
        
        cp.errors = append(cp.errors, err)
}</span>

// GetResults returns the processed results
func (cp *ChunkProcessor) GetResults() ([]*models.Span, []error, int64) <span class="cov8" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()
        
        return cp.spans, cp.errors, cp.memoryUsed
}</span>

// Clear clears the processor state
func (cp *ChunkProcessor) Clear() <span class="cov8" title="1">{
        cp.mu.Lock()
        defer cp.mu.Unlock()
        
        cp.spans = cp.spans[:0]
        cp.errors = cp.errors[:0]
        cp.memoryUsed = 0
}</span>

// estimateSpanMemory estimates memory usage of a span
func (cp *ChunkProcessor) estimateSpanMemory(span *models.Span) int64 <span class="cov8" title="1">{
        // Rough estimation of span memory usage
        baseSize := int64(200) // Base struct size
        
        // Add string fields
        baseSize += int64(len(span.SpanID))
        baseSize += int64(len(span.TraceID))
        baseSize += int64(len(span.ParentID))
        baseSize += int64(len(span.Name))
        baseSize += int64(len(span.Status.Code))
        baseSize += int64(len(span.Status.Message))
        
        // Add attributes (rough estimation)
        for key, value := range span.Attributes </span><span class="cov8" title="1">{
                baseSize += int64(len(key))
                if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                        baseSize += int64(len(str))
                }</span> else<span class="cov0" title="0"> {
                        baseSize += 50 // Rough estimate for other types
                }</span>
        }
        
        // Add events
        <span class="cov8" title="1">for _, event := range span.Events </span><span class="cov0" title="0">{
                baseSize += int64(len(event.Name))
                for key, value := range event.Attributes </span><span class="cov0" title="0">{
                        baseSize += int64(len(key))
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                baseSize += int64(len(str))
                        }</span> else<span class="cov0" title="0"> {
                                baseSize += 50
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return baseSize</span>
}

// Utility functions for memory optimization

// OptimizeMemoryUsage performs memory optimization operations
func OptimizeMemoryUsage() <span class="cov8" title="1">{
        // Force garbage collection
        runtime.GC()
        
        // Return memory to OS
        runtime.GC()
        runtime.GC() // Call twice for better effect
}</span>

// GetMemoryStats returns current memory statistics
func GetMemoryStats() map[string]interface{} <span class="cov8" title="1">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        
        return map[string]interface{}{
                "alloc":         m.Alloc,         // Currently allocated bytes
                "total_alloc":   m.TotalAlloc,    // Total allocated bytes (cumulative)
                "sys":           m.Sys,           // System memory obtained from OS
                "num_gc":        m.NumGC,         // Number of GC cycles
                "gc_cpu_fraction": m.GCCPUFraction, // Fraction of CPU time used by GC
                "heap_alloc":    m.HeapAlloc,     // Heap allocated bytes
                "heap_sys":      m.HeapSys,       // Heap system bytes
                "heap_objects":  m.HeapObjects,   // Number of heap objects
        }
}</pre>
		
		<pre class="file" id="file4" style="display: none">package models

import (
        "encoding/json"
        "fmt"
)

// ServiceSpec represents a service specification with preconditions and postconditions
type ServiceSpec struct {
        OperationID    string                 `json:"operationId"`
        Description    string                 `json:"description"`
        Preconditions  map[string]interface{} `json:"preconditions"`
        Postconditions map[string]interface{} `json:"postconditions"`
        SourceFile     string                 `json:"sourceFile"`
        LineNumber     int                    `json:"lineNumber"`
}

// ParseResult contains the results of parsing ServiceSpecs from source files
type ParseResult struct {
        Specs   []ServiceSpec          `json:"specs"`
        Errors  []ParseError           `json:"errors"`
        Metrics map[string]interface{} `json:"metrics,omitempty"`
}

// ParseError represents an error that occurred during parsing
type ParseError struct {
        File    string `json:"file"`
        Line    int    `json:"line"`
        Message string `json:"message"`
}

// Validate checks if the ServiceSpec has all required fields
func (s *ServiceSpec) Validate() error <span class="cov8" title="1">{
        if s.OperationID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("operationId is required")
        }</span>
        <span class="cov8" title="1">if s.Description == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("description is required")
        }</span>
        <span class="cov8" title="1">if s.SourceFile == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("sourceFile is required")
        }</span>
        <span class="cov8" title="1">if s.LineNumber &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("lineNumber must be positive")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ToJSON serializes the ServiceSpec to JSON
func (s *ServiceSpec) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(s)
}</span>

// FromJSON deserializes JSON data into a ServiceSpec
func (s *ServiceSpec) FromJSON(data []byte) error <span class="cov8" title="1">{
        return json.Unmarshal(data, s)
}</span>

// String returns a string representation of the ServiceSpec
func (s *ServiceSpec) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ServiceSpec{OperationID: %s, Description: %s, SourceFile: %s, LineNumber: %d}",
                s.OperationID, s.Description, s.SourceFile, s.LineNumber)
}</span>

// Error returns a string representation of the ParseError
func (e *ParseError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d: %s", e.File, e.Line, e.Message)
}</span>

// Trace-related data structures

// TraceData represents a complete trace with all its spans organized for efficient querying
type TraceData struct {
        TraceID   string             `json:"traceId"`
        RootSpan  *Span             `json:"rootSpan"`
        Spans     map[string]*Span  `json:"spans"`
        SpanTree  *SpanNode         `json:"spanTree"`
}

// Span represents a single span in an OpenTelemetry trace
type Span struct {
        SpanID     string                 `json:"spanId"`
        TraceID    string                 `json:"traceId"`
        ParentID   string                 `json:"parentSpanId,omitempty"`
        Name       string                 `json:"name"`
        StartTime  int64                  `json:"startTime"`  // Unix timestamp in nanoseconds
        EndTime    int64                  `json:"endTime"`    // Unix timestamp in nanoseconds
        Status     SpanStatus             `json:"status"`
        Attributes map[string]interface{} `json:"attributes"`
        Events     []SpanEvent            `json:"events"`
}

// SpanStatus represents the status of a span
type SpanStatus struct {
        Code    string `json:"code"`    // "OK", "ERROR", "TIMEOUT"
        Message string `json:"message"`
}

// SpanEvent represents an event within a span
type SpanEvent struct {
        Name       string                 `json:"name"`
        Timestamp  int64                  `json:"timestamp"` // Unix timestamp in nanoseconds
        Attributes map[string]interface{} `json:"attributes"`
}

// SpanNode represents a node in the span tree structure
type SpanNode struct {
        Span     *Span      `json:"span"`
        Children []*SpanNode `json:"children"`
}

// BuildSpanTree constructs a hierarchical tree structure from the spans in TraceData
func (td *TraceData) BuildSpanTree() error <span class="cov8" title="1">{
        if len(td.Spans) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no spans available to build tree")
        }</span>

        // Find root span (span with no parent)
        <span class="cov8" title="1">var rootSpan *Span
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.ParentID == "" </span><span class="cov8" title="1">{
                        rootSpan = span
                        break</span>
                }
        }

        <span class="cov8" title="1">if rootSpan == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no root span found")
        }</span>

        <span class="cov8" title="1">td.RootSpan = rootSpan
        td.SpanTree = &amp;SpanNode{
                Span:     rootSpan,
                Children: []*SpanNode{},
        }

        // Build the tree recursively
        td.buildSpanTreeRecursive(td.SpanTree)
        return nil</span>
}

// buildSpanTreeRecursive recursively builds the span tree
func (td *TraceData) buildSpanTreeRecursive(node *SpanNode) <span class="cov8" title="1">{
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.ParentID == node.Span.SpanID </span><span class="cov8" title="1">{
                        childNode := &amp;SpanNode{
                                Span:     span,
                                Children: []*SpanNode{},
                        }
                        node.Children = append(node.Children, childNode)
                        td.buildSpanTreeRecursive(childNode)
                }</span>
        }
}

// GetDuration returns the duration of the span in nanoseconds
func (s *Span) GetDuration() int64 <span class="cov8" title="1">{
        return s.EndTime - s.StartTime
}</span>

// IsRoot returns true if this span is a root span (has no parent)
func (s *Span) IsRoot() bool <span class="cov8" title="1">{
        return s.ParentID == ""
}</span>

// HasError returns true if the span has an error status
func (s *Span) HasError() bool <span class="cov8" title="1">{
        return s.Status.Code == "ERROR"
}</span>

// GetAttribute returns the value of a span attribute, or nil if not found
func (s *Span) GetAttribute(key string) interface{} <span class="cov8" title="1">{
        if s.Attributes == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.Attributes[key]</span>
}

// AddEvent adds an event to the span
func (s *Span) AddEvent(event SpanEvent) <span class="cov8" title="1">{
        if s.Events == nil </span><span class="cov8" title="1">{
                s.Events = []SpanEvent{}
        }</span>
        <span class="cov8" title="1">s.Events = append(s.Events, event)</span>
}

// String returns a string representation of the Span
func (s *Span) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Span{SpanID: %s, TraceID: %s, Name: %s, Status: %s}",
                s.SpanID, s.TraceID, s.Name, s.Status.Code)
}</span>

// GetDepth returns the depth of this node in the span tree (root = 0)
func (sn *SpanNode) GetDepth() int <span class="cov0" title="0">{
        depth := 0
        // This would need to be calculated from the tree structure
        // For now, we'll implement a simple version
        return depth
}</span>

// GetChildCount returns the number of direct children
func (sn *SpanNode) GetChildCount() int <span class="cov8" title="1">{
        return len(sn.Children)
}</span>

// GetTotalDescendants returns the total number of descendants (children + grandchildren + ...)
func (sn *SpanNode) GetTotalDescendants() int <span class="cov8" title="1">{
        total := len(sn.Children)
        for _, child := range sn.Children </span><span class="cov8" title="1">{
                total += child.GetTotalDescendants()
        }</span>
        <span class="cov8" title="1">return total</span>
}

// FindSpanByID searches for a span by ID in the trace data
func (td *TraceData) FindSpanByID(spanID string) *Span <span class="cov8" title="1">{
        return td.Spans[spanID]
}</span>

// FindSpansByName searches for spans by name in the trace data
func (td *TraceData) FindSpansByName(name string) []*Span <span class="cov8" title="1">{
        var result []*Span
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.Name == name </span><span class="cov8" title="1">{
                        result = append(result, span)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetAllSpans returns all spans in the trace as a slice
func (td *TraceData) GetAllSpans() []*Span <span class="cov8" title="1">{
        spans := make([]*Span, 0, len(td.Spans))
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                spans = append(spans, span)
        }</span>
        <span class="cov8" title="1">return spans</span>
}

// AlignmentReport-related data structures

// AlignmentReport represents the complete report of alignment verification
type AlignmentReport struct {
        Summary         AlignmentSummary  `json:"summary"`
        Results         []AlignmentResult `json:"results"`
        ExecutionTime   int64             `json:"executionTime"`   // Total execution time in nanoseconds
        StartTime       int64             `json:"startTime"`       // Start timestamp in Unix nanoseconds
        EndTime         int64             `json:"endTime"`         // End timestamp in Unix nanoseconds
        PerformanceInfo PerformanceInfo   `json:"performanceInfo"` // Performance monitoring data
}

// AlignmentSummary provides summary statistics for the alignment report
type AlignmentSummary struct {
        Total              int     `json:"total"`
        Success            int     `json:"success"`
        Failed             int     `json:"failed"`
        Skipped            int     `json:"skipped"`
        SuccessRate        float64 `json:"successRate"`        // Success rate as percentage (0.0 to 1.0)
        FailureRate        float64 `json:"failureRate"`        // Failure rate as percentage (0.0 to 1.0)
        SkipRate           float64 `json:"skipRate"`           // Skip rate as percentage (0.0 to 1.0)
        AverageExecutionTime int64 `json:"averageExecutionTime"` // Average execution time per spec in nanoseconds
        TotalAssertions    int     `json:"totalAssertions"`    // Total number of assertions evaluated
        FailedAssertions   int     `json:"failedAssertions"`   // Number of failed assertions
}

// PerformanceInfo contains performance monitoring data
type PerformanceInfo struct {
        SpecsProcessed       int     `json:"specsProcessed"`       // Number of specs processed
        SpansMatched         int     `json:"spansMatched"`         // Number of spans matched
        AssertionsEvaluated  int     `json:"assertionsEvaluated"`  // Total assertions evaluated
        ConcurrentWorkers    int     `json:"concurrentWorkers"`    // Number of concurrent workers used
        MemoryUsageMB        float64 `json:"memoryUsageMB"`        // Peak memory usage in MB
        ProcessingRate       float64 `json:"processingRate"`       // Specs processed per second
}

// AlignmentResult represents the result of aligning a single ServiceSpec with trace data
type AlignmentResult struct {
        SpecOperationID   string            `json:"specOperationId"`
        Status            AlignmentStatus   `json:"status"`
        Details           []ValidationDetail `json:"details"`
        ExecutionTime     int64             `json:"executionTime"`     // Duration in nanoseconds
        StartTime         int64             `json:"startTime"`         // Start timestamp in Unix nanoseconds
        EndTime           int64             `json:"endTime"`           // End timestamp in Unix nanoseconds
        MatchedSpans      []string          `json:"matchedSpans"`      // IDs of spans that matched this spec
        AssertionsTotal   int               `json:"assertionsTotal"`   // Total number of assertions evaluated
        AssertionsPassed  int               `json:"assertionsPassed"`  // Number of assertions that passed
        AssertionsFailed  int               `json:"assertionsFailed"`  // Number of assertions that failed
        ErrorMessage      string            `json:"errorMessage,omitempty"` // Error message if processing failed
}

// AlignmentStatus represents the status of an alignment result
type AlignmentStatus string

const (
        StatusSuccess AlignmentStatus = "SUCCESS"
        StatusFailed  AlignmentStatus = "FAILED"
        StatusSkipped AlignmentStatus = "SKIPPED"
)

// ValidationDetail provides detailed information about a specific validation
type ValidationDetail struct {
        Type          string                 `json:"type"`                    // "precondition" | "postcondition"
        Expression    string                 `json:"expression"`
        Expected      interface{}            `json:"expected"`
        Actual        interface{}            `json:"actual"`
        Message       string                 `json:"message"`
        SpanContext   *Span                  `json:"spanContext,omitempty"`
        FailureReason string                 `json:"failureReason,omitempty"` // Detailed analysis of why the assertion failed
        ContextInfo   map[string]interface{} `json:"contextInfo,omitempty"`   // Additional context information for debugging
        Suggestions   []string               `json:"suggestions,omitempty"`   // Actionable suggestions for fixing the failure
}

// AddResult adds an alignment result to the report and updates the summary
func (ar *AlignmentReport) AddResult(result AlignmentResult) <span class="cov8" title="1">{
        ar.Results = append(ar.Results, result)
        ar.updateSummary()
}</span>

// updateSummary recalculates the summary statistics based on current results
func (ar *AlignmentReport) updateSummary() <span class="cov8" title="1">{
        total := len(ar.Results)
        success := 0
        failed := 0
        skipped := 0
        totalExecutionTime := int64(0)
        totalAssertions := 0
        failedAssertions := 0

        for _, result := range ar.Results </span><span class="cov8" title="1">{
                switch result.Status </span>{
                case StatusSuccess:<span class="cov8" title="1">
                        success++</span>
                case StatusFailed:<span class="cov8" title="1">
                        failed++</span>
                case StatusSkipped:<span class="cov8" title="1">
                        skipped++</span>
                }
                
                <span class="cov8" title="1">totalExecutionTime += result.ExecutionTime
                totalAssertions += result.AssertionsTotal
                failedAssertions += result.AssertionsFailed</span>
        }

        <span class="cov8" title="1">ar.Summary = AlignmentSummary{
                Total:           total,
                Success:         success,
                Failed:          failed,
                Skipped:         skipped,
                TotalAssertions: totalAssertions,
                FailedAssertions: failedAssertions,
        }

        // Calculate rates
        if total &gt; 0 </span><span class="cov8" title="1">{
                ar.Summary.SuccessRate = float64(success) / float64(total)
                ar.Summary.FailureRate = float64(failed) / float64(total)
                ar.Summary.SkipRate = float64(skipped) / float64(total)
                ar.Summary.AverageExecutionTime = totalExecutionTime / int64(total)
        }</span>
}

// HasFailures returns true if any alignment results have failed
func (ar *AlignmentReport) HasFailures() bool <span class="cov8" title="1">{
        return ar.Summary.Failed &gt; 0
}</span>

// GetSuccessRate returns the success rate as a percentage (0.0 to 1.0)
func (ar *AlignmentReport) GetSuccessRate() float64 <span class="cov8" title="1">{
        if ar.Summary.Total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(ar.Summary.Success) / float64(ar.Summary.Total)</span>
}

// GetFailureRate returns the failure rate as a percentage (0.0 to 1.0)
func (ar *AlignmentReport) GetFailureRate() float64 <span class="cov8" title="1">{
        if ar.Summary.Total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(ar.Summary.Failed) / float64(ar.Summary.Total)</span>
}

// String returns a string representation of the AlignmentStatus
func (as AlignmentStatus) String() string <span class="cov8" title="1">{
        return string(as)
}</span>

// IsValid returns true if the AlignmentStatus is one of the valid values
func (as AlignmentStatus) IsValid() bool <span class="cov8" title="1">{
        switch as </span>{
        case StatusSuccess, StatusFailed, StatusSkipped:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// AddValidationDetail adds a validation detail to the alignment result
func (ar *AlignmentResult) AddValidationDetail(detail ValidationDetail) <span class="cov8" title="1">{
        ar.Details = append(ar.Details, detail)
        
        // Update status based on validation details
        ar.updateStatus()
}</span>

// updateStatus updates the alignment result status based on validation details
func (ar *AlignmentResult) updateStatus() <span class="cov8" title="1">{
        if len(ar.Details) == 0 </span><span class="cov0" title="0">{
                ar.Status = StatusSkipped
                ar.AssertionsTotal = 0
                ar.AssertionsPassed = 0
                ar.AssertionsFailed = 0
                return
        }</span>

        <span class="cov8" title="1">totalAssertions := 0
        passedAssertions := 0
        failedAssertions := 0
        hasFailure := false

        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                // Skip "matching" type details as they are not assertions
                if detail.Type == "matching" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov8" title="1">totalAssertions++
                
                // Check if this assertion passed or failed
                if detail.IsPassed() </span><span class="cov8" title="1">{
                        passedAssertions++
                }</span> else<span class="cov8" title="1"> {
                        failedAssertions++
                        hasFailure = true
                }</span>
        }

        <span class="cov8" title="1">ar.AssertionsTotal = totalAssertions
        ar.AssertionsPassed = passedAssertions
        ar.AssertionsFailed = failedAssertions

        // Determine overall status
        if hasFailure </span><span class="cov8" title="1">{
                ar.Status = StatusFailed
        }</span> else<span class="cov8" title="1"> if totalAssertions &gt; 0 </span><span class="cov8" title="1">{
                ar.Status = StatusSuccess
        }</span> else<span class="cov0" title="0"> {
                ar.Status = StatusSkipped
        }</span>
}

// GetFailedDetails returns only the validation details that failed
func (ar *AlignmentResult) GetFailedDetails() []ValidationDetail <span class="cov8" title="1">{
        var failed []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Expected != detail.Actual </span><span class="cov8" title="1">{
                        failed = append(failed, detail)
                }</span>
        }
        <span class="cov8" title="1">return failed</span>
}

// GetPreconditionDetails returns only the precondition validation details
func (ar *AlignmentResult) GetPreconditionDetails() []ValidationDetail <span class="cov8" title="1">{
        var preconditions []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Type == "precondition" </span><span class="cov8" title="1">{
                        preconditions = append(preconditions, detail)
                }</span>
        }
        <span class="cov8" title="1">return preconditions</span>
}

// GetPostconditionDetails returns only the postcondition validation details
func (ar *AlignmentResult) GetPostconditionDetails() []ValidationDetail <span class="cov8" title="1">{
        var postconditions []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Type == "postcondition" </span><span class="cov8" title="1">{
                        postconditions = append(postconditions, detail)
                }</span>
        }
        <span class="cov8" title="1">return postconditions</span>
}

// String returns a string representation of the ValidationDetail
func (vd *ValidationDetail) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ValidationDetail{Type: %s, Expression: %s, Expected: %v, Actual: %v}",
                vd.Type, vd.Expression, vd.Expected, vd.Actual)
}</span>

// IsPassed returns true if the validation detail passed (expected equals actual)
func (vd *ValidationDetail) IsPassed() bool <span class="cov8" title="1">{
        return vd.Expected == vd.Actual
}</span>

// NewAlignmentReport creates a new empty alignment report
func NewAlignmentReport() *AlignmentReport <span class="cov8" title="1">{
        return &amp;AlignmentReport{
                Summary: AlignmentSummary{},
                Results: []AlignmentResult{},
        }
}</span>

// NewAlignmentResult creates a new alignment result with the given operation ID
func NewAlignmentResult(operationID string) *AlignmentResult <span class="cov8" title="1">{
        return &amp;AlignmentResult{
                SpecOperationID: operationID,
                Status:          StatusSkipped, // Default to skipped until validation details are added
                Details:         []ValidationDetail{},
                ExecutionTime:   0,
        }
}</span>

// NewValidationDetail creates a new validation detail
func NewValidationDetail(detailType, expression string, expected, actual interface{}, message string) *ValidationDetail <span class="cov8" title="1">{
        return &amp;ValidationDetail{
                Type:       detailType,
                Expression: expression,
                Expected:   expected,
                Actual:     actual,
                Message:    message,
        }
}</pre>
		
		<pre class="file" id="file5" style="display: none">package parser

import (
        "bufio"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "flowspec-cli/internal/models"
        "gopkg.in/yaml.v3"
)

// BaseFileParser provides common functionality for parsing ServiceSpec annotations
type BaseFileParser struct {
        language         SupportedLanguage
        commentPatterns  []CommentPattern
        errorCollector   *ErrorCollector
}

// CommentPattern defines how comments are structured in different languages
type CommentPattern struct {
        StartPattern string // e.g., "/**", "//"
        EndPattern   string // e.g., "*/", "" (empty for single-line)
        LinePrefix   string // e.g., " * ", "// "
        IsMultiLine  bool
}

// ServiceSpecAnnotation represents a parsed ServiceSpec annotation
type ServiceSpecAnnotation struct {
        OperationID    string
        Description    string
        Preconditions  interface{}
        Postconditions interface{}
        StartLine      int
        EndLine        int
}

// NewBaseFileParser creates a new base file parser
func NewBaseFileParser(language SupportedLanguage) *BaseFileParser <span class="cov8" title="1">{
        return &amp;BaseFileParser{
                language:        language,
                commentPatterns: getCommentPatterns(language),
                errorCollector:  NewErrorCollector(),
        }
}</span>

// getCommentPatterns returns comment patterns for different languages
func getCommentPatterns(language SupportedLanguage) []CommentPattern <span class="cov8" title="1">{
        switch language </span>{
        case LanguageJava:<span class="cov8" title="1">
                return []CommentPattern{
                        {
                                StartPattern: "/**",
                                EndPattern:   "*/",
                                LinePrefix:   " * ",
                                IsMultiLine:  true,
                        },
                        {
                                StartPattern: "/*",
                                EndPattern:   "*/",
                                LinePrefix:   " * ",
                                IsMultiLine:  true,
                        },
                }</span>
        case LanguageTypeScript:<span class="cov8" title="1">
                return []CommentPattern{
                        {
                                StartPattern: "/**",
                                EndPattern:   "*/",
                                LinePrefix:   " * ",
                                IsMultiLine:  true,
                        },
                        {
                                StartPattern: "/*",
                                EndPattern:   "*/",
                                LinePrefix:   " * ",
                                IsMultiLine:  true,
                        },
                        {
                                StartPattern: "//",
                                EndPattern:   "",
                                LinePrefix:   "// ",
                                IsMultiLine:  false,
                        },
                }</span>
        case LanguageGo:<span class="cov8" title="1">
                return []CommentPattern{
                        {
                                StartPattern: "/*",
                                EndPattern:   "*/",
                                LinePrefix:   " * ",
                                IsMultiLine:  true,
                        },
                        {
                                StartPattern: "//",
                                EndPattern:   "",
                                LinePrefix:   "// ",
                                IsMultiLine:  false,
                        },
                }</span>
        default:<span class="cov0" title="0">
                return []CommentPattern{}</span>
        }
}

// ParseFile parses a file and extracts ServiceSpec annotations
func (bp *BaseFileParser) ParseFile(filepath string) ([]models.ServiceSpec, []models.ParseError) <span class="cov8" title="1">{
        bp.errorCollector.Clear()
        
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov8" title="1">{
                bp.errorCollector.AddError(filepath, 0, fmt.Sprintf("failed to open file: %s", err.Error()))
                return []models.ServiceSpec{}, bp.errorCollector.GetErrors()
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        // Read file line by line
        scanner := bufio.NewScanner(file)
        var lines []string
        for scanner.Scan() </span><span class="cov8" title="1">{
                lines = append(lines, scanner.Text())
        }</span>
        
        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                bp.errorCollector.AddError(filepath, 0, fmt.Sprintf("failed to read file: %s", err.Error()))
                return []models.ServiceSpec{}, bp.errorCollector.GetErrors()
        }</span>
        
        // Extract ServiceSpec annotations
        <span class="cov8" title="1">annotations := bp.extractServiceSpecAnnotations(lines, filepath)
        
        // Convert annotations to ServiceSpec objects
        var specs []models.ServiceSpec
        for _, annotation := range annotations </span><span class="cov8" title="1">{
                spec, err := bp.convertAnnotationToSpec(annotation, filepath)
                if err != nil </span><span class="cov8" title="1">{
                        bp.errorCollector.AddError(filepath, annotation.StartLine, err.Error())
                        continue</span>
                }
                <span class="cov8" title="1">specs = append(specs, spec)</span>
        }
        
        <span class="cov8" title="1">return specs, bp.errorCollector.GetErrors()</span>
}

// extractServiceSpecAnnotations finds and extracts ServiceSpec annotations from file lines
func (bp *BaseFileParser) extractServiceSpecAnnotations(lines []string, filepath string) []ServiceSpecAnnotation <span class="cov8" title="1">{
        var annotations []ServiceSpecAnnotation
        
        for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                line := strings.TrimSpace(lines[i])
                
                // Look for ServiceSpec annotation start
                if bp.isServiceSpecStart(line) </span><span class="cov8" title="1">{
                        annotation, endLine := bp.parseServiceSpecAnnotation(lines, i, filepath)
                        if annotation != nil </span><span class="cov8" title="1">{
                                annotations = append(annotations, *annotation)
                        }</span>
                        // Move to the end line to avoid re-processing
                        <span class="cov8" title="1">if endLine &gt; i </span><span class="cov8" title="1">{
                                i = endLine
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return annotations</span>
}

// isServiceSpecStart checks if a line starts a ServiceSpec annotation
func (bp *BaseFileParser) isServiceSpecStart(line string) bool <span class="cov8" title="1">{
        // Look for @ServiceSpec in various comment formats
        patterns := []string{
                `@ServiceSpec`,
                `\*\s*@ServiceSpec`,
                `//\s*@ServiceSpec`,
        }
        
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                matched, _ := regexp.MatchString(pattern, line)
                if matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        
        <span class="cov8" title="1">return false</span>
}

// parseServiceSpecAnnotation parses a complete ServiceSpec annotation
func (bp *BaseFileParser) parseServiceSpecAnnotation(lines []string, startLine int, filepath string) (*ServiceSpecAnnotation, int) <span class="cov8" title="1">{
        annotation := &amp;ServiceSpecAnnotation{
                StartLine: startLine + 1, // Convert to 1-based line numbers
        }
        
        // Look backwards to find the start of the comment block
        commentStart := startLine
        for commentStart &gt; 0 </span><span class="cov8" title="1">{
                prevLine := strings.TrimSpace(lines[commentStart-1])
                if strings.Contains(prevLine, "/**") || strings.Contains(prevLine, "/*") </span><span class="cov8" title="1">{
                        commentStart = commentStart - 1
                        break</span>
                }
                <span class="cov8" title="1">if strings.HasPrefix(prevLine, "*") || strings.HasPrefix(prevLine, " *") </span><span class="cov8" title="1">{
                        commentStart = commentStart - 1
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        
        // Determine comment pattern from the actual comment start
        <span class="cov8" title="1">pattern := bp.detectCommentPattern(lines[commentStart])
        if pattern == nil </span><span class="cov0" title="0">{
                // Try to detect from the current line
                pattern = bp.detectCommentPattern(lines[startLine])
                if pattern == nil </span><span class="cov0" title="0">{
                        bp.errorCollector.AddError(filepath, startLine+1, "unable to detect comment pattern")
                        return nil, startLine
                }</span>
        }
        
        // Extract annotation content starting from the comment start
        <span class="cov8" title="1">content, endLine := bp.extractAnnotationContent(lines, commentStart, pattern)
        annotation.EndLine = endLine + 1
        
        // Parse the content
        if err := bp.parseAnnotationContent(content, annotation, filepath); err != nil </span><span class="cov8" title="1">{
                bp.errorCollector.AddError(filepath, startLine+1, err.Error())
                return nil, endLine
        }</span>
        
        <span class="cov8" title="1">return annotation, endLine</span>
}

// detectCommentPattern determines which comment pattern is being used
func (bp *BaseFileParser) detectCommentPattern(line string) *CommentPattern <span class="cov8" title="1">{
        trimmedLine := strings.TrimSpace(line)
        
        // Check patterns in order of specificity (longer patterns first)
        for _, pattern := range bp.commentPatterns </span><span class="cov8" title="1">{
                if strings.Contains(trimmedLine, pattern.StartPattern) </span><span class="cov8" title="1">{
                        // Return a copy of the pattern to avoid modifying the original
                        patternCopy := pattern
                        return &amp;patternCopy
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// extractAnnotationContent extracts the content of a ServiceSpec annotation
func (bp *BaseFileParser) extractAnnotationContent(lines []string, startLine int, pattern *CommentPattern) (string, int) <span class="cov8" title="1">{
        var content strings.Builder
        currentLine := startLine
        
        if pattern.IsMultiLine </span><span class="cov8" title="1">{
                // Multi-line comment (/* */ or /** */)
                inAnnotation := false
                
                for currentLine &lt; len(lines) </span><span class="cov8" title="1">{
                        line := lines[currentLine]
                        
                        if strings.Contains(line, "@ServiceSpec") </span><span class="cov8" title="1">{
                                inAnnotation = true
                                currentLine++
                                continue</span> // Skip the @ServiceSpec line itself
                        }
                        
                        <span class="cov8" title="1">if inAnnotation </span><span class="cov8" title="1">{
                                // Check for end of comment first
                                if strings.Contains(line, pattern.EndPattern) </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                
                                // Clean the line
                                <span class="cov8" title="1">cleaned := bp.cleanCommentLine(line, pattern)
                                if cleaned != "" </span><span class="cov8" title="1">{
                                        content.WriteString(cleaned)
                                        content.WriteString("\n")
                                }</span>
                        }
                        
                        <span class="cov8" title="1">currentLine++</span>
                }
        } else<span class="cov8" title="1"> {
                // Single-line comments (//)
                foundServiceSpec := false
                
                for currentLine &lt; len(lines) </span><span class="cov8" title="1">{
                        line := lines[currentLine]
                        trimmedLine := strings.TrimSpace(line)
                        
                        // Check if this line is still part of the comment
                        if !strings.HasPrefix(trimmedLine, strings.TrimSpace(pattern.StartPattern)) </span><span class="cov8" title="1">{
                                break</span>
                        }
                        
                        <span class="cov8" title="1">if strings.Contains(line, "@ServiceSpec") </span><span class="cov8" title="1">{
                                foundServiceSpec = true
                                currentLine++
                                continue</span> // Skip the @ServiceSpec line itself
                        }
                        
                        <span class="cov8" title="1">if foundServiceSpec </span><span class="cov8" title="1">{
                                cleaned := bp.cleanCommentLine(line, pattern)
                                if cleaned != "" </span><span class="cov8" title="1">{
                                        content.WriteString(cleaned)
                                        content.WriteString("\n")
                                }</span>
                        }
                        
                        <span class="cov8" title="1">currentLine++</span>
                }
                <span class="cov8" title="1">currentLine--</span> // Adjust for the last line that wasn't part of the comment
        }
        
        <span class="cov8" title="1">return content.String(), currentLine</span>
}

// cleanCommentLine removes comment markers from a line while preserving indentation
func (bp *BaseFileParser) cleanCommentLine(line string, pattern *CommentPattern) string <span class="cov8" title="1">{
        cleaned := line
        
        // Remove start pattern
        if pattern.StartPattern != "" </span><span class="cov8" title="1">{
                cleaned = strings.Replace(cleaned, pattern.StartPattern, "", 1)
        }</span>
        
        // Remove end pattern
        <span class="cov8" title="1">if pattern.EndPattern != "" </span><span class="cov8" title="1">{
                cleaned = strings.Replace(cleaned, pattern.EndPattern, "", 1)
        }</span>
        
        // For multi-line comments, remove the line prefix but preserve indentation after it
        <span class="cov8" title="1">if pattern.IsMultiLine &amp;&amp; pattern.LinePrefix != "" </span><span class="cov8" title="1">{
                // Find the line prefix and remove it, but keep any indentation after it
                prefixIndex := strings.Index(cleaned, strings.TrimSpace(pattern.LinePrefix))
                if prefixIndex &gt;= 0 </span><span class="cov8" title="1">{
                        // Remove everything up to and including the prefix
                        cleaned = cleaned[prefixIndex+len(strings.TrimSpace(pattern.LinePrefix)):]
                }</span>
        } else<span class="cov8" title="1"> if pattern.LinePrefix != "" </span><span class="cov8" title="1">{
                // For single-line comments, remove the prefix but preserve indentation
                prefixToRemove := strings.TrimSpace(pattern.LinePrefix)
                if strings.HasPrefix(strings.TrimSpace(cleaned), prefixToRemove) </span><span class="cov0" title="0">{
                        // Find the prefix position and remove it, keeping leading whitespace
                        trimmed := strings.TrimSpace(cleaned)
                        prefixIndex := strings.Index(trimmed, prefixToRemove)
                        if prefixIndex == 0 </span><span class="cov0" title="0">{
                                // Remove the prefix and any immediately following space
                                remaining := trimmed[len(prefixToRemove):]
                                if strings.HasPrefix(remaining, " ") </span><span class="cov0" title="0">{
                                        remaining = remaining[1:]
                                }</span>
                                // Preserve the original indentation structure for YAML
                                <span class="cov0" title="0">leadingSpaces := len(cleaned) - len(strings.TrimLeft(cleaned, " \t"))
                                if leadingSpaces &gt; 0 &amp;&amp; remaining != "" </span><span class="cov0" title="0">{
                                        // Keep some indentation for YAML structure
                                        cleaned = strings.Repeat(" ", max(0, leadingSpaces-2)) + remaining
                                }</span> else<span class="cov0" title="0"> {
                                        cleaned = remaining
                                }</span>
                        }
                }
        }
        
        // Remove @ServiceSpec marker if present
        <span class="cov8" title="1">cleaned = regexp.MustCompile(`@ServiceSpec\s*`).ReplaceAllString(cleaned, "")
        
        // Don't trim the result to preserve indentation
        return cleaned</span>
}

// parseAnnotationContent parses the extracted annotation content
func (bp *BaseFileParser) parseAnnotationContent(content string, annotation *ServiceSpecAnnotation, filepath string) error <span class="cov8" title="1">{
        if content == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("empty ServiceSpec annotation")
        }</span>
        
        // Try to parse as YAML first (more flexible)
        <span class="cov8" title="1">var data map[string]interface{}
        if err := yaml.Unmarshal([]byte(content), &amp;data); err != nil </span><span class="cov8" title="1">{
                // If YAML fails, try JSON
                if jsonErr := json.Unmarshal([]byte(content), &amp;data); jsonErr != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to parse annotation content as YAML or JSON: %s", err.Error())
                }</span>
        }
        
        // Extract required fields
        <span class="cov8" title="1">if operationID, ok := data["operationId"].(string); ok </span><span class="cov8" title="1">{
                annotation.OperationID = operationID
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("missing or invalid operationId field")
        }</span>
        
        <span class="cov8" title="1">if description, ok := data["description"].(string); ok </span><span class="cov8" title="1">{
                annotation.Description = description
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("missing or invalid description field")
        }</span>
        
        // Extract optional fields
        <span class="cov8" title="1">if preconditions, ok := data["preconditions"]; ok </span><span class="cov8" title="1">{
                annotation.Preconditions = preconditions
        }</span>
        
        <span class="cov8" title="1">if postconditions, ok := data["postconditions"]; ok </span><span class="cov8" title="1">{
                annotation.Postconditions = postconditions
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// convertAnnotationToSpec converts a ServiceSpecAnnotation to a models.ServiceSpec
func (bp *BaseFileParser) convertAnnotationToSpec(annotation ServiceSpecAnnotation, filepath string) (models.ServiceSpec, error) <span class="cov8" title="1">{
        spec := models.ServiceSpec{
                OperationID: annotation.OperationID,
                Description: annotation.Description,
                SourceFile:  filepath,
                LineNumber:  annotation.StartLine,
        }
        
        // Convert preconditions to map[string]interface{}
        if annotation.Preconditions != nil </span><span class="cov8" title="1">{
                if preconditions, ok := annotation.Preconditions.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        spec.Preconditions = preconditions
                }</span> else<span class="cov8" title="1"> {
                        return spec, fmt.Errorf("preconditions must be a map/object")
                }</span>
        } else<span class="cov8" title="1"> {
                spec.Preconditions = make(map[string]interface{})
        }</span>
        
        // Convert postconditions to map[string]interface{}
        <span class="cov8" title="1">if annotation.Postconditions != nil </span><span class="cov8" title="1">{
                if postconditions, ok := annotation.Postconditions.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        spec.Postconditions = postconditions
                }</span> else<span class="cov0" title="0"> {
                        return spec, fmt.Errorf("postconditions must be a map/object")
                }</span>
        } else<span class="cov8" title="1"> {
                spec.Postconditions = make(map[string]interface{})
        }</span>
        
        // Validate the spec
        <span class="cov8" title="1">if err := spec.Validate(); err != nil </span><span class="cov0" title="0">{
                return spec, fmt.Errorf("invalid ServiceSpec: %s", err.Error())
        }</span>
        
        <span class="cov8" title="1">return spec, nil</span>
}

// CanParse checks if this parser can handle the given file
func (bp *BaseFileParser) CanParse(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        
        switch bp.language </span>{
        case LanguageJava:<span class="cov8" title="1">
                return ext == ".java"</span>
        case LanguageTypeScript:<span class="cov8" title="1">
                return ext == ".ts" || ext == ".tsx"</span>
        case LanguageGo:<span class="cov8" title="1">
                return ext == ".go"</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// GetLanguage returns the language this parser handles
func (bp *BaseFileParser) GetLanguage() SupportedLanguage <span class="cov8" title="1">{
        return bp.language
}</span>

// GetErrorCount returns the number of errors collected during parsing
func (bp *BaseFileParser) GetErrorCount() int <span class="cov8" title="1">{
        return bp.errorCollector.Count()
}</span>

// ClearErrors clears all collected errors
func (bp *BaseFileParser) ClearErrors() <span class="cov8" title="1">{
        bp.errorCollector.Clear()
}</span>

// ValidateJSONLogic validates that the given data can be processed by JSONLogic
func (bp *BaseFileParser) ValidateJSONLogic(data interface{}) error <span class="cov8" title="1">{
        // Basic validation - check if it's a valid JSON structure
        if data == nil </span><span class="cov8" title="1">{
                return nil // Empty conditions are allowed
        }</span>
        
        // Try to marshal and unmarshal to ensure it's valid JSON
        <span class="cov8" title="1">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid JSON structure: %s", err.Error())
        }</span>
        
        <span class="cov8" title="1">var result interface{}
        if err := json.Unmarshal(jsonData, &amp;result); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid JSON structure: %s", err.Error())
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// Helper function to convert line numbers (for debugging)
func (bp *BaseFileParser) formatLineNumber(line int) string <span class="cov0" title="0">{
        return strconv.Itoa(line)
}</span>

// Helper function to get the maximum of two integers
func max(a, b int) int <span class="cov0" title="0">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}</pre>
		
		<pre class="file" id="file6" style="display: none">package parser

import (
        "flowspec-cli/internal/models"
)

// GoFileParser implements FileParser for Go source files
type GoFileParser struct {
        *BaseFileParser
}

// NewGoFileParser creates a new Go file parser
func NewGoFileParser() *GoFileParser <span class="cov8" title="1">{
        return &amp;GoFileParser{
                BaseFileParser: NewBaseFileParser(LanguageGo),
        }
}</span>

// CanParse checks if this parser can handle the given file
func (gp *GoFileParser) CanParse(filename string) bool <span class="cov8" title="1">{
        return gp.BaseFileParser.CanParse(filename)
}</span>

// ParseFile parses a Go file and extracts ServiceSpec annotations
func (gp *GoFileParser) ParseFile(filepath string) ([]models.ServiceSpec, []models.ParseError) <span class="cov8" title="1">{
        return gp.BaseFileParser.ParseFile(filepath)
}</pre>
		
		<pre class="file" id="file7" style="display: none">package parser

import (
        "flowspec-cli/internal/models"
)

// JavaFileParser implements FileParser for Java source files
type JavaFileParser struct {
        *BaseFileParser
}

// NewJavaFileParser creates a new Java file parser
func NewJavaFileParser() *JavaFileParser <span class="cov8" title="1">{
        return &amp;JavaFileParser{
                BaseFileParser: NewBaseFileParser(LanguageJava),
        }
}</span>

// CanParse checks if this parser can handle the given file
func (jp *JavaFileParser) CanParse(filename string) bool <span class="cov8" title="1">{
        return jp.BaseFileParser.CanParse(filename)
}</span>

// ParseFile parses a Java file and extracts ServiceSpec annotations
func (jp *JavaFileParser) ParseFile(filepath string) ([]models.ServiceSpec, []models.ParseError) <span class="cov8" title="1">{
        return jp.BaseFileParser.ParseFile(filepath)
}</pre>
		
		<pre class="file" id="file8" style="display: none">package parser

import (
        "crypto/md5"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "flowspec-cli/internal/models"
)

// SpecParser defines the interface for parsing ServiceSpecs from source code
type SpecParser interface {
        ParseFromSource(sourcePath string) (*models.ParseResult, error)
}

// FileParser defines the interface for parsing individual files
type FileParser interface {
        CanParse(filename string) bool
        ParseFile(filepath string) ([]models.ServiceSpec, []models.ParseError)
}

// SupportedLanguage represents a supported programming language
type SupportedLanguage string

const (
        LanguageJava       SupportedLanguage = "java"
        LanguageTypeScript SupportedLanguage = "typescript"
        LanguageGo         SupportedLanguage = "go"
)

// FileType represents the mapping between file extensions and languages
type FileType struct {
        Extensions []string
        Language   SupportedLanguage
}

// DefaultSpecParser implements the SpecParser interface
type DefaultSpecParser struct {
        fileParsers    map[SupportedLanguage]FileParser
        supportedTypes []FileType
        maxWorkers     int
        cache          *ParseCache
        mu             sync.RWMutex
}

// ParserConfig holds configuration for the parser
type ParserConfig struct {
        MaxWorkers     int
        SkipHidden     bool
        SkipVendor     bool
        MaxFileSize    int64 // Maximum file size in bytes
        AllowedDirs    []string
        ExcludedDirs   []string
        EnableCache    bool
        CacheSize      int
        EnableMetrics  bool
}

// ParseCache provides caching for parsed files
type ParseCache struct {
        entries map[string]*CacheEntry
        maxSize int
        mu      sync.RWMutex
}

// CacheEntry represents a cached parse result
type CacheEntry struct {
        FilePath     string
        FileHash     string
        ModTime      time.Time
        Specs        []models.ServiceSpec
        Errors       []models.ParseError
        LastAccessed time.Time
}

// ParseMetrics tracks parsing performance
type ParseMetrics struct {
        TotalFiles      int
        ProcessedFiles  int
        CacheHits       int
        CacheMisses     int
        TotalSpecs      int
        TotalErrors     int
        ParseDuration   time.Duration
        StartTime       time.Time
        mu              sync.RWMutex
}

// DefaultParserConfig returns a default parser configuration
func DefaultParserConfig() *ParserConfig <span class="cov8" title="1">{
        return &amp;ParserConfig{
                MaxWorkers:    4,
                SkipHidden:    true,
                SkipVendor:    true,
                MaxFileSize:   10 * 1024 * 1024, // 10MB
                AllowedDirs:   []string{},
                ExcludedDirs:  []string{"node_modules", "vendor", ".git", "build", "dist", "target"},
                EnableCache:   true,
                CacheSize:     1000,
                EnableMetrics: true,
        }
}</span>

// NewParseCache creates a new parse cache
func NewParseCache(maxSize int) *ParseCache <span class="cov8" title="1">{
        return &amp;ParseCache{
                entries: make(map[string]*CacheEntry),
                maxSize: maxSize,
        }
}</span>

// NewParseMetrics creates a new parse metrics tracker
func NewParseMetrics() *ParseMetrics <span class="cov8" title="1">{
        return &amp;ParseMetrics{
                StartTime: time.Now(),
        }
}</span>

// NewSpecParser creates a new SpecParser with default configuration
func NewSpecParser() *DefaultSpecParser <span class="cov8" title="1">{
        config := DefaultParserConfig()
        parser := &amp;DefaultSpecParser{
                fileParsers:    make(map[SupportedLanguage]FileParser),
                supportedTypes: getSupportedFileTypes(),
                maxWorkers:     config.MaxWorkers,
                cache:          NewParseCache(config.CacheSize),
        }
        
        // Register default file parsers
        parser.RegisterFileParser(LanguageJava, NewJavaFileParser())
        parser.RegisterFileParser(LanguageTypeScript, NewTypeScriptFileParser())
        parser.RegisterFileParser(LanguageGo, NewGoFileParser())
        
        return parser
}</span>

// NewSpecParserWithConfig creates a new SpecParser with custom configuration
func NewSpecParserWithConfig(config *ParserConfig) *DefaultSpecParser <span class="cov8" title="1">{
        parser := &amp;DefaultSpecParser{
                fileParsers:    make(map[SupportedLanguage]FileParser),
                supportedTypes: getSupportedFileTypes(),
                maxWorkers:     config.MaxWorkers,
        }
        
        if config.EnableCache </span><span class="cov8" title="1">{
                parser.cache = NewParseCache(config.CacheSize)
        }</span>
        
        // Register default file parsers
        <span class="cov8" title="1">parser.RegisterFileParser(LanguageJava, NewJavaFileParser())
        parser.RegisterFileParser(LanguageTypeScript, NewTypeScriptFileParser())
        parser.RegisterFileParser(LanguageGo, NewGoFileParser())
        
        return parser</span>
}

// RegisterFileParser registers a file parser for a specific language
func (p *DefaultSpecParser) RegisterFileParser(language SupportedLanguage, parser FileParser) <span class="cov8" title="1">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.fileParsers[language] = parser
}</span>

// GetFileParser returns the file parser for a specific language
func (p *DefaultSpecParser) GetFileParser(language SupportedLanguage) (FileParser, bool) <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        parser, exists := p.fileParsers[language]
        return parser, exists
}</span>

// ParseFromSource implements the SpecParser interface
func (p *DefaultSpecParser) ParseFromSource(sourcePath string) (*models.ParseResult, error) <span class="cov8" title="1">{
        startTime := time.Now()
        metrics := NewParseMetrics()
        
        // Validate source path
        if sourcePath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source path cannot be empty")
        }</span>
        
        <span class="cov8" title="1">info, err := os.Stat(sourcePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to access source path %s: %w", sourcePath, err)
        }</span>
        
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("source path %s is not a directory", sourcePath)
        }</span>
        
        // Scan for supported files
        <span class="cov8" title="1">files, err := p.scanFiles(sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan files: %w", err)
        }</span>
        
        <span class="cov8" title="1">metrics.TotalFiles = len(files)
        
        if len(files) == 0 </span><span class="cov8" title="1">{
                return &amp;models.ParseResult{
                        Specs:  []models.ServiceSpec{},
                        Errors: []models.ParseError{},
                }, nil
        }</span>
        
        // Parse files concurrently
        <span class="cov8" title="1">result, err := p.parseFilesWithMetrics(files, metrics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // Update metrics
        <span class="cov8" title="1">metrics.ProcessedFiles = len(files)
        metrics.TotalSpecs = len(result.Specs)
        metrics.TotalErrors = len(result.Errors)
        metrics.SetParseDuration(time.Since(startTime))
        
        // Add metrics to result if available
        if result != nil </span><span class="cov8" title="1">{
                result.Metrics = metrics.GetSummary()
        }</span>
        
        <span class="cov8" title="1">return result, nil</span>
}

// scanFiles recursively scans the directory for supported source files
func (p *DefaultSpecParser) scanFiles(rootPath string) ([]string, error) <span class="cov8" title="1">{
        var files []string
        
        err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue walking
                        return nil
                }</span>
                
                // Skip directories
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Check if directory should be excluded
                        if p.shouldSkipDirectory(path, info.Name()) </span><span class="cov8" title="1">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
                
                // Check if file should be processed
                <span class="cov8" title="1">if p.shouldProcessFile(path, info) </span><span class="cov8" title="1">{
                        files = append(files, path)
                }</span>
                
                <span class="cov8" title="1">return nil</span>
        })
        
        <span class="cov8" title="1">return files, err</span>
}

// shouldSkipDirectory determines if a directory should be skipped during scanning
func (p *DefaultSpecParser) shouldSkipDirectory(path, name string) bool <span class="cov8" title="1">{
        // Skip hidden directories
        if strings.HasPrefix(name, ".") &amp;&amp; name != "." </span><span class="cov8" title="1">{
                return true
        }</span>
        
        // Skip common vendor/build directories
        <span class="cov8" title="1">excludedDirs := []string{
                "node_modules", "vendor", ".git", "build", "dist", "target",
                ".idea", ".vscode", "__pycache__", ".gradle", ".mvn",
        }
        
        for _, excluded := range excludedDirs </span><span class="cov8" title="1">{
                if name == excluded </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        
        <span class="cov8" title="1">return false</span>
}

// shouldProcessFile determines if a file should be processed
func (p *DefaultSpecParser) shouldProcessFile(path string, info os.FileInfo) bool <span class="cov8" title="1">{
        // Skip if file is too large
        if info.Size() &gt; 10*1024*1024 </span><span class="cov8" title="1">{ // 10MB limit
                return false
        }</span>
        
        // Check if file extension is supported
        <span class="cov8" title="1">return p.isSupportedFile(path)</span>
}

// isSupportedFile checks if a file has a supported extension
func (p *DefaultSpecParser) isSupportedFile(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        
        for _, fileType := range p.supportedTypes </span><span class="cov8" title="1">{
                for _, supportedExt := range fileType.Extensions </span><span class="cov8" title="1">{
                        if ext == supportedExt </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return false</span>
}

// getLanguageFromFile determines the programming language from file extension
func (p *DefaultSpecParser) getLanguageFromFile(filename string) (SupportedLanguage, error) <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))
        
        for _, fileType := range p.supportedTypes </span><span class="cov8" title="1">{
                for _, supportedExt := range fileType.Extensions </span><span class="cov8" title="1">{
                        if ext == supportedExt </span><span class="cov8" title="1">{
                                return fileType.Language, nil
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return "", fmt.Errorf("unsupported file extension: %s", ext)</span>
}

// parseFiles parses multiple files concurrently
func (p *DefaultSpecParser) parseFiles(files []string) (*models.ParseResult, error) <span class="cov0" title="0">{
        return p.parseFilesWithMetrics(files, nil)
}</span>

// parseFilesWithMetrics parses multiple files concurrently with metrics tracking
func (p *DefaultSpecParser) parseFilesWithMetrics(files []string, metrics *ParseMetrics) (*models.ParseResult, error) <span class="cov8" title="1">{
        if len(files) == 0 </span><span class="cov0" title="0">{
                return &amp;models.ParseResult{
                        Specs:  []models.ServiceSpec{},
                        Errors: []models.ParseError{},
                }, nil
        }</span>
        
        // Create channels for results
        <span class="cov8" title="1">specsChan := make(chan []models.ServiceSpec, len(files))
        errorsChan := make(chan []models.ParseError, len(files))
        
        // Create worker pool
        workers := p.maxWorkers
        if workers &gt; len(files) </span><span class="cov8" title="1">{
                workers = len(files)
        }</span>
        
        <span class="cov8" title="1">fileChan := make(chan string, len(files))
        var wg sync.WaitGroup
        
        // Start workers
        for i := 0; i &lt; workers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        p.parseWorkerWithMetrics(fileChan, specsChan, errorsChan, metrics)
                }</span>()
        }
        
        // Send files to workers
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                fileChan &lt;- file
        }</span>
        <span class="cov8" title="1">close(fileChan)
        
        // Wait for workers to complete
        wg.Wait()
        close(specsChan)
        close(errorsChan)
        
        // Collect results
        var allSpecs []models.ServiceSpec
        var allErrors []models.ParseError
        
        for specs := range specsChan </span><span class="cov8" title="1">{
                allSpecs = append(allSpecs, specs...)
        }</span>
        
        <span class="cov8" title="1">for errors := range errorsChan </span><span class="cov8" title="1">{
                allErrors = append(allErrors, errors...)
        }</span>
        
        <span class="cov8" title="1">return &amp;models.ParseResult{
                Specs:  allSpecs,
                Errors: allErrors,
        }, nil</span>
}

// parseWorker is a worker function that processes files from the channel
func (p *DefaultSpecParser) parseWorker(fileChan &lt;-chan string, specsChan chan&lt;- []models.ServiceSpec, errorsChan chan&lt;- []models.ParseError) <span class="cov0" title="0">{
        p.parseWorkerWithMetrics(fileChan, specsChan, errorsChan, nil)
}</span>

// parseWorkerWithMetrics is a worker function that processes files from the channel with metrics tracking
func (p *DefaultSpecParser) parseWorkerWithMetrics(fileChan &lt;-chan string, specsChan chan&lt;- []models.ServiceSpec, errorsChan chan&lt;- []models.ParseError, metrics *ParseMetrics) <span class="cov8" title="1">{
        for file := range fileChan </span><span class="cov8" title="1">{
                specs, errors := p.parseFileWithMetrics(file, metrics)
                specsChan &lt;- specs
                errorsChan &lt;- errors
        }</span>
}

// parseFile parses a single file with caching support
func (p *DefaultSpecParser) parseFile(filepath string) ([]models.ServiceSpec, []models.ParseError) <span class="cov0" title="0">{
        return p.parseFileWithMetrics(filepath, nil)
}</span>

// parseFileWithMetrics parses a single file with caching support and metrics tracking
func (p *DefaultSpecParser) parseFileWithMetrics(filepath string, metrics *ParseMetrics) ([]models.ServiceSpec, []models.ParseError) <span class="cov8" title="1">{
        // Get file info for caching
        fileInfo, err := os.Stat(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []models.ParseError{{
                        File:    filepath,
                        Line:    0,
                        Message: fmt.Sprintf("failed to stat file: %s", err.Error()),
                }}
        }</span>
        
        // Check cache first
        <span class="cov8" title="1">if p.cache != nil </span><span class="cov8" title="1">{
                if entry, found := p.cache.Get(filepath, fileInfo.ModTime()); found </span><span class="cov8" title="1">{
                        if metrics != nil </span><span class="cov8" title="1">{
                                metrics.IncrementCacheHit()
                        }</span>
                        <span class="cov8" title="1">return entry.Specs, entry.Errors</span>
                }
                <span class="cov8" title="1">if metrics != nil </span><span class="cov8" title="1">{
                        metrics.IncrementCacheMiss()
                }</span>
        }
        
        // Determine language from file extension
        <span class="cov8" title="1">language, err := p.getLanguageFromFile(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, []models.ParseError{{
                        File:    filepath,
                        Line:    0,
                        Message: fmt.Sprintf("unsupported file type: %s", err.Error()),
                }}
        }</span>
        
        // Get appropriate file parser
        <span class="cov8" title="1">fileParser, exists := p.GetFileParser(language)
        if !exists </span><span class="cov0" title="0">{
                return nil, []models.ParseError{{
                        File:    filepath,
                        Line:    0,
                        Message: fmt.Sprintf("no parser registered for language: %s", language),
                }}
        }</span>
        
        // Parse the file
        <span class="cov8" title="1">specs, errors := fileParser.ParseFile(filepath)
        
        // Cache the result
        if p.cache != nil </span><span class="cov8" title="1">{
                p.cache.Put(filepath, fileInfo.ModTime(), specs, errors)
        }</span>
        
        <span class="cov8" title="1">return specs, errors</span>
}

// getSupportedFileTypes returns the list of supported file types
func getSupportedFileTypes() []FileType <span class="cov8" title="1">{
        return []FileType{
                {
                        Extensions: []string{".java"},
                        Language:   LanguageJava,
                },
                {
                        Extensions: []string{".ts", ".tsx"},
                        Language:   LanguageTypeScript,
                },
                {
                        Extensions: []string{".go"},
                        Language:   LanguageGo,
                },
        }
}</span>

// GetSupportedLanguages returns a list of all supported languages
func (p *DefaultSpecParser) GetSupportedLanguages() []SupportedLanguage <span class="cov8" title="1">{
        var languages []SupportedLanguage
        for _, fileType := range p.supportedTypes </span><span class="cov8" title="1">{
                languages = append(languages, fileType.Language)
        }</span>
        <span class="cov8" title="1">return languages</span>
}

// GetSupportedExtensions returns a list of all supported file extensions
func (p *DefaultSpecParser) GetSupportedExtensions() []string <span class="cov8" title="1">{
        var extensions []string
        for _, fileType := range p.supportedTypes </span><span class="cov8" title="1">{
                extensions = append(extensions, fileType.Extensions...)
        }</span>
        <span class="cov8" title="1">return extensions</span>
}

// IsLanguageSupported checks if a language is supported
func (p *DefaultSpecParser) IsLanguageSupported(language SupportedLanguage) bool <span class="cov8" title="1">{
        for _, fileType := range p.supportedTypes </span><span class="cov8" title="1">{
                if fileType.Language == language </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetFileCount returns the number of registered file parsers
func (p *DefaultSpecParser) GetFileCount() int <span class="cov8" title="1">{
        p.mu.RLock()
        defer p.mu.RUnlock()
        return len(p.fileParsers)
}</span>

// GetCacheSize returns the current cache size
func (p *DefaultSpecParser) GetCacheSize() int <span class="cov8" title="1">{
        if p.cache == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return p.cache.Size()</span>
}

// ClearCache clears the parse cache
func (p *DefaultSpecParser) ClearCache() <span class="cov0" title="0">{
        if p.cache != nil </span><span class="cov0" title="0">{
                p.cache.Clear()
        }</span>
}

// SetMaxWorkers updates the maximum number of worker goroutines
func (p *DefaultSpecParser) SetMaxWorkers(maxWorkers int) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        if maxWorkers &gt; 0 </span><span class="cov0" title="0">{
                p.maxWorkers = maxWorkers
        }</span>
}

// ErrorCollector provides utilities for collecting and managing parse errors
type ErrorCollector struct {
        errors []models.ParseError
        mu     sync.Mutex
}

// NewErrorCollector creates a new error collector
func NewErrorCollector() *ErrorCollector <span class="cov8" title="1">{
        return &amp;ErrorCollector{
                errors: make([]models.ParseError, 0),
        }
}</span>

// AddError adds a parse error to the collector
func (ec *ErrorCollector) AddError(file string, line int, message string) <span class="cov8" title="1">{
        ec.mu.Lock()
        defer ec.mu.Unlock()
        ec.errors = append(ec.errors, models.ParseError{
                File:    file,
                Line:    line,
                Message: message,
        })
}</span>

// AddErrorf adds a formatted parse error to the collector
func (ec *ErrorCollector) AddErrorf(file string, line int, format string, args ...interface{}) <span class="cov8" title="1">{
        ec.AddError(file, line, fmt.Sprintf(format, args...))
}</span>

// GetErrors returns all collected errors
func (ec *ErrorCollector) GetErrors() []models.ParseError <span class="cov8" title="1">{
        ec.mu.Lock()
        defer ec.mu.Unlock()
        // Return a copy to prevent external modification
        result := make([]models.ParseError, len(ec.errors))
        copy(result, ec.errors)
        return result
}</span>

// HasErrors returns true if any errors have been collected
func (ec *ErrorCollector) HasErrors() bool <span class="cov8" title="1">{
        ec.mu.Lock()
        defer ec.mu.Unlock()
        return len(ec.errors) &gt; 0
}</span>

// Clear removes all collected errors
func (ec *ErrorCollector) Clear() <span class="cov8" title="1">{
        ec.mu.Lock()
        defer ec.mu.Unlock()
        ec.errors = ec.errors[:0]
}</span>

// Count returns the number of collected errors
func (ec *ErrorCollector) Count() int <span class="cov8" title="1">{
        ec.mu.Lock()
        defer ec.mu.Unlock()
        return len(ec.errors)
}</span>

// Cache methods

// Get retrieves a cached entry if it exists and is still valid
func (pc *ParseCache) Get(filePath string, modTime time.Time) (*CacheEntry, bool) <span class="cov8" title="1">{
        if pc == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        
        <span class="cov8" title="1">pc.mu.RLock()
        defer pc.mu.RUnlock()
        
        entry, exists := pc.entries[filePath]
        if !exists </span><span class="cov8" title="1">{
                return nil, false
        }</span>
        
        // Check if file has been modified
        <span class="cov8" title="1">if !entry.ModTime.Equal(modTime) </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        
        // Update last accessed time
        <span class="cov8" title="1">entry.LastAccessed = time.Now()
        return entry, true</span>
}

// Put stores a parse result in the cache
func (pc *ParseCache) Put(filePath string, modTime time.Time, specs []models.ServiceSpec, errors []models.ParseError) <span class="cov8" title="1">{
        if pc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov8" title="1">pc.mu.Lock()
        defer pc.mu.Unlock()
        
        // If cache is full, remove least recently used entry
        if len(pc.entries) &gt;= pc.maxSize </span><span class="cov0" title="0">{
                pc.evictLRU()
        }</span>
        
        // Calculate file hash for integrity check
        <span class="cov8" title="1">hash, _ := pc.calculateFileHash(filePath)
        
        entry := &amp;CacheEntry{
                FilePath:     filePath,
                FileHash:     hash,
                ModTime:      modTime,
                Specs:        specs,
                Errors:       errors,
                LastAccessed: time.Now(),
        }
        
        pc.entries[filePath] = entry</span>
}

// evictLRU removes the least recently used entry from cache
func (pc *ParseCache) evictLRU() <span class="cov0" title="0">{
        var oldestPath string
        var oldestTime time.Time
        
        for path, entry := range pc.entries </span><span class="cov0" title="0">{
                if oldestPath == "" || entry.LastAccessed.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestPath = path
                        oldestTime = entry.LastAccessed
                }</span>
        }
        
        <span class="cov0" title="0">if oldestPath != "" </span><span class="cov0" title="0">{
                delete(pc.entries, oldestPath)
        }</span>
}

// calculateFileHash calculates MD5 hash of file content
func (pc *ParseCache) calculateFileHash(filePath string) (string, error) <span class="cov8" title="1">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()
        
        hash := md5.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// Clear removes all entries from the cache
func (pc *ParseCache) Clear() <span class="cov0" title="0">{
        if pc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        
        <span class="cov0" title="0">pc.mu.Lock()
        defer pc.mu.Unlock()
        pc.entries = make(map[string]*CacheEntry)</span>
}

// Size returns the current number of cached entries
func (pc *ParseCache) Size() int <span class="cov8" title="1">{
        if pc == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        
        <span class="cov8" title="1">pc.mu.RLock()
        defer pc.mu.RUnlock()
        return len(pc.entries)</span>
}

// Metrics methods

// IncrementCacheHit increments the cache hit counter
func (pm *ParseMetrics) IncrementCacheHit() <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.CacheHits++
}</span>

// IncrementCacheMiss increments the cache miss counter
func (pm *ParseMetrics) IncrementCacheMiss() <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.CacheMisses++
}</span>

// AddFile increments the total file counter
func (pm *ParseMetrics) AddFile() <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.TotalFiles++
}</span>

// AddProcessedFile increments the processed file counter
func (pm *ParseMetrics) AddProcessedFile() <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.ProcessedFiles++
}</span>

// AddSpecs adds to the total specs counter
func (pm *ParseMetrics) AddSpecs(count int) <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.TotalSpecs += count
}</span>

// AddErrors adds to the total errors counter
func (pm *ParseMetrics) AddErrors(count int) <span class="cov0" title="0">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.TotalErrors += count
}</span>

// SetParseDuration sets the total parse duration
func (pm *ParseMetrics) SetParseDuration(duration time.Duration) <span class="cov8" title="1">{
        pm.mu.Lock()
        defer pm.mu.Unlock()
        pm.ParseDuration = duration
}</span>

// GetSummary returns a summary of parsing metrics
func (pm *ParseMetrics) GetSummary() map[string]interface{} <span class="cov8" title="1">{
        pm.mu.RLock()
        defer pm.mu.RUnlock()
        
        return map[string]interface{}{
                "total_files":      pm.TotalFiles,
                "processed_files":  pm.ProcessedFiles,
                "cache_hits":       pm.CacheHits,
                "cache_misses":     pm.CacheMisses,
                "total_specs":      pm.TotalSpecs,
                "total_errors":     pm.TotalErrors,
                "parse_duration":   pm.ParseDuration.String(),
                "files_per_second": float64(pm.ProcessedFiles) / pm.ParseDuration.Seconds(),
        }
}</pre>
		
		<pre class="file" id="file9" style="display: none">package parser

import (
        "flowspec-cli/internal/models"
)

// TypeScriptFileParser implements FileParser for TypeScript source files
type TypeScriptFileParser struct {
        *BaseFileParser
}

// NewTypeScriptFileParser creates a new TypeScript file parser
func NewTypeScriptFileParser() *TypeScriptFileParser <span class="cov8" title="1">{
        return &amp;TypeScriptFileParser{
                BaseFileParser: NewBaseFileParser(LanguageTypeScript),
        }
}</span>

// CanParse checks if this parser can handle the given file
func (tp *TypeScriptFileParser) CanParse(filename string) bool <span class="cov8" title="1">{
        return tp.BaseFileParser.CanParse(filename)
}</span>

// ParseFile parses a TypeScript file and extracts ServiceSpec annotations
func (tp *TypeScriptFileParser) ParseFile(filepath string) ([]models.ServiceSpec, []models.ParseError) <span class="cov8" title="1">{
        return tp.BaseFileParser.ParseFile(filepath)
}</pre>
		
		<pre class="file" id="file10" style="display: none">package renderer

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "flowspec-cli/internal/models"
)

// ReportRenderer defines the interface for rendering alignment reports
type ReportRenderer interface {
        RenderHuman(report *models.AlignmentReport) (string, error)
        RenderJSON(report *models.AlignmentReport) (string, error)
        GetExitCode(report *models.AlignmentReport) int
}

// DefaultReportRenderer implements the ReportRenderer interface
type DefaultReportRenderer struct {
        config *RendererConfig
}

// RendererConfig holds configuration for the report renderer
type RendererConfig struct {
        ShowTimestamps    bool
        ShowPerformance   bool
        ShowDetailedErrors bool
        ColorOutput       bool
}

// DefaultRendererConfig returns a default renderer configuration
func DefaultRendererConfig() *RendererConfig <span class="cov8" title="1">{
        return &amp;RendererConfig{
                ShowTimestamps:    true,
                ShowPerformance:   true,
                ShowDetailedErrors: true,
                ColorOutput:       true,
        }
}</span>

// NewReportRenderer creates a new report renderer with default configuration
func NewReportRenderer() *DefaultReportRenderer <span class="cov8" title="1">{
        return &amp;DefaultReportRenderer{
                config: DefaultRendererConfig(),
        }
}</span>

// NewReportRendererWithConfig creates a new report renderer with custom configuration
func NewReportRendererWithConfig(config *RendererConfig) *DefaultReportRenderer <span class="cov8" title="1">{
        return &amp;DefaultReportRenderer{
                config: config,
        }
}</span>

// RenderHuman implements the ReportRenderer interface with enhanced formatting and color support
func (r *DefaultReportRenderer) RenderHuman(report *models.AlignmentReport) (string, error) <span class="cov8" title="1">{
        var output strings.Builder
        
        // Header with enhanced styling
        r.writeColoredHeader(&amp;output, "FlowSpec ")
        output.WriteString("==================================================\n\n")
        
        // Summary statistics with color coding
        r.writeColoredSection(&amp;output, " ")
        output.WriteString(fmt.Sprintf("  : %s%d%s  ServiceSpec\n", 
                r.getColor("bold"), report.Summary.Total, r.getColor("reset")))
        
        // Success count with green color
        output.WriteString(fmt.Sprintf("  %s : %s%d%s %s", 
                r.getColor("green"), r.getColor("bold"), report.Summary.Success, r.getColor("reset"), r.getColor("reset")))
        if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                successRate := float64(report.Summary.Success) / float64(report.Summary.Total) * 100
                output.WriteString(fmt.Sprintf(" (%.1f%%)", successRate))
        }</span>
        <span class="cov8" title="1">output.WriteString("\n")
        
        // Failed count with red color
        if report.Summary.Failed &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("  %s : %s%d%s %s", 
                        r.getColor("red"), r.getColor("bold"), report.Summary.Failed, r.getColor("reset"), r.getColor("reset")))
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        failureRate := float64(report.Summary.Failed) / float64(report.Summary.Total) * 100
                        output.WriteString(fmt.Sprintf(" (%.1f%%)", failureRate))
                }</span>
                <span class="cov8" title="1">output.WriteString("\n")</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("  %s : %s0%s %s\n", 
                        r.getColor("dim"), r.getColor("dim"), r.getColor("reset"), r.getColor("reset")))
        }</span>
        
        // Skipped count with yellow color
        <span class="cov8" title="1">if report.Summary.Skipped &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("  %s  : %s%d%s %s", 
                        r.getColor("yellow"), r.getColor("bold"), report.Summary.Skipped, r.getColor("reset"), r.getColor("reset")))
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        skipRate := float64(report.Summary.Skipped) / float64(report.Summary.Total) * 100
                        output.WriteString(fmt.Sprintf(" (%.1f%%)", skipRate))
                }</span>
                <span class="cov8" title="1">output.WriteString("\n")</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("  %s  : %s0%s %s\n", 
                        r.getColor("dim"), r.getColor("dim"), r.getColor("reset"), r.getColor("reset")))
        }</span>
        
        // Performance metrics with enhanced formatting
        <span class="cov8" title="1">if r.config.ShowPerformance &amp;&amp; report.PerformanceInfo.SpecsProcessed &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString("\n")
                r.writeColoredSubsection(&amp;output, " ")
                output.WriteString(fmt.Sprintf("  : %s%.2f%s specs/\n", 
                        r.getColor("cyan"), report.PerformanceInfo.ProcessingRate, r.getColor("reset")))
                output.WriteString(fmt.Sprintf("  : %s%.2f%s MB\n", 
                        r.getColor("cyan"), report.PerformanceInfo.MemoryUsageMB, r.getColor("reset")))
                if report.PerformanceInfo.ConcurrentWorkers &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("  : %s%d%s \n", 
                                r.getColor("cyan"), report.PerformanceInfo.ConcurrentWorkers, r.getColor("reset")))
                }</span>
                <span class="cov8" title="1">if report.Summary.TotalAssertions &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("  : %s%d%s \n", 
                                r.getColor("cyan"), report.Summary.TotalAssertions, r.getColor("reset")))
                }</span>
        }
        
        // Execution time with enhanced formatting
        <span class="cov8" title="1">if r.config.ShowTimestamps </span><span class="cov8" title="1">{
                executionTime := time.Duration(report.ExecutionTime)
                output.WriteString(fmt.Sprintf("    : %s%v%s\n", 
                        r.getColor("magenta"), executionTime, r.getColor("reset")))
                
                // Show average time per spec if meaningful
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        avgTime := time.Duration(report.Summary.AverageExecutionTime)
                        output.WriteString(fmt.Sprintf("  : %s%v%s/spec\n", 
                                r.getColor("magenta"), avgTime, r.getColor("reset")))
                }</span>
        }
        
        <span class="cov8" title="1">output.WriteString("\n")
        r.writeColoredSection(&amp;output, " ")
        output.WriteString("\n\n")
        
        // Group results by status for better readability
        successResults := []models.AlignmentResult{}
        failedResults := []models.AlignmentResult{}
        skippedResults := []models.AlignmentResult{}
        
        for _, result := range report.Results </span><span class="cov8" title="1">{
                switch result.Status </span>{
                case models.StatusSuccess:<span class="cov8" title="1">
                        successResults = append(successResults, result)</span>
                case models.StatusFailed:<span class="cov8" title="1">
                        failedResults = append(failedResults, result)</span>
                case models.StatusSkipped:<span class="cov8" title="1">
                        skippedResults = append(skippedResults, result)</span>
                }
        }
        
        // Render failed results first (most important)
        <span class="cov8" title="1">if len(failedResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("  (%d )", len(failedResults)))
                for i, result := range failedResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(failedResults))
                        if i &lt; len(failedResults)-1 </span><span class="cov0" title="0">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Render successful results
        <span class="cov8" title="1">if len(successResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("  (%d )", len(successResults)))
                for i, result := range successResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(successResults))
                        if i &lt; len(successResults)-1 </span><span class="cov8" title="1">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Render skipped results last
        <span class="cov8" title="1">if len(skippedResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("   (%d )", len(skippedResults)))
                for i, result := range skippedResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(skippedResults))
                        if i &lt; len(skippedResults)-1 </span><span class="cov0" title="0">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Final summary with enhanced styling
        <span class="cov8" title="1">output.WriteString("==================================================\n")
        if report.HasFailures() </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("%s:  %s (%s%d%s )\n", 
                        r.getColor("red"), r.getColor("reset"), 
                        r.getColor("bold"), report.Summary.FailedAssertions, r.getColor("reset")))
                
                // Provide actionable summary for failures
                if report.Summary.FailedAssertions &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("\n%s :%s\n", r.getColor("yellow"), r.getColor("reset")))
                        output.WriteString("   \n")
                        output.WriteString("    span \n")
                        output.WriteString("    ServiceSpec \n")
                }</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("%s:  %s ()\n", 
                        r.getColor("green"), r.getColor("reset")))
                
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("\n%s %s  %d  ServiceSpec \n", 
                                r.getColor("green"), r.getColor("reset"), report.Summary.Total))
                }</span>
        }
        
        <span class="cov8" title="1">return output.String(), nil</span>
}

// renderResultHuman renders a single alignment result in human format with enhanced styling
func (r *DefaultReportRenderer) renderResultHuman(output *strings.Builder, result models.AlignmentResult, index, total int) <span class="cov8" title="1">{
        // Status icon and operation ID with color coding
        statusIcon := r.getStatusIcon(result.Status)
        statusColor := r.getStatusColor(result.Status)
        
        output.WriteString(fmt.Sprintf("%s[%d/%d]%s %s %s%s%s (%s%s%s)\n", 
                r.getColor("dim"), index, total, r.getColor("reset"),
                statusIcon, 
                r.getColor("bold"), result.SpecOperationID, r.getColor("reset"),
                statusColor, result.Status, r.getColor("reset")))
        
        // Execution time with formatting
        if r.config.ShowTimestamps </span><span class="cov8" title="1">{
                executionTime := time.Duration(result.ExecutionTime)
                output.WriteString(fmt.Sprintf("     : %s%v%s\n", 
                        r.getColor("dim"), executionTime, r.getColor("reset")))
        }</span>
        
        // Matched spans with enhanced formatting
        <span class="cov8" title="1">if len(result.MatchedSpans) &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("     Span: %s%s%s\n", 
                        r.getColor("cyan"), strings.Join(result.MatchedSpans, ", "), r.getColor("reset")))
        }</span> else<span class="cov8" title="1"> if result.Status == models.StatusSkipped </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %s  Span%s\n", 
                        r.getColor("yellow"), r.getColor("reset")))
        }</span>
        
        // Assertion summary with color coding
        <span class="cov8" title="1">if result.AssertionsTotal &gt; 0 </span><span class="cov8" title="1">{
                passedColor := r.getColor("green")
                failedColor := r.getColor("red")
                if result.AssertionsPassed == 0 </span><span class="cov8" title="1">{
                        passedColor = r.getColor("dim")
                }</span>
                <span class="cov8" title="1">if result.AssertionsFailed == 0 </span><span class="cov8" title="1">{
                        failedColor = r.getColor("dim")
                }</span>
                
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("    : %s%d%s , %s%d%s , %s%d%s \n", 
                        r.getColor("bold"), result.AssertionsTotal, r.getColor("reset"),
                        passedColor, result.AssertionsPassed, r.getColor("reset"),
                        failedColor, result.AssertionsFailed, r.getColor("reset")))</span>
        }
        
        // Error message for failed results with enhanced formatting
        <span class="cov8" title="1">if result.Status == models.StatusFailed &amp;&amp; result.ErrorMessage != "" </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %s  :%s %s\n", 
                        r.getColor("red"), r.getColor("reset"), result.ErrorMessage))
        }</span>
        
        // Detailed validation results with improved readability
        <span class="cov8" title="1">if r.config.ShowDetailedErrors &amp;&amp; len(result.Details) &gt; 0 </span><span class="cov8" title="1">{
                r.renderValidationDetailsHuman(output, result.Details)
        }</span>
}

// renderValidationDetailsHuman renders validation details in human format with enhanced styling
func (r *DefaultReportRenderer) renderValidationDetailsHuman(output *strings.Builder, details []models.ValidationDetail) <span class="cov8" title="1">{
        preconditions := []models.ValidationDetail{}
        postconditions := []models.ValidationDetail{}
        matchingDetails := []models.ValidationDetail{}
        
        for _, detail := range details </span><span class="cov8" title="1">{
                switch detail.Type </span>{
                case "precondition":<span class="cov0" title="0">
                        preconditions = append(preconditions, detail)</span>
                case "postcondition":<span class="cov8" title="1">
                        postconditions = append(postconditions, detail)</span>
                case "matching":<span class="cov0" title="0">
                        matchingDetails = append(matchingDetails, detail)</span>
                }
        }
        
        // Render matching details first (if any)
        <span class="cov8" title="1">if len(matchingDetails) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %s Span :%s\n", 
                        r.getColor("cyan"), r.getColor("reset")))
                for _, detail := range matchingDetails </span><span class="cov0" title="0">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
        
        // Render preconditions
        <span class="cov8" title="1">if len(preconditions) &gt; 0 </span><span class="cov0" title="0">{
                passedCount := 0
                for _, detail := range preconditions </span><span class="cov0" title="0">{
                        if detail.IsPassed() </span><span class="cov0" title="0">{
                                passedCount++
                        }</span>
                }
                
                <span class="cov0" title="0">statusIcon := ""
                statusColor := r.getColor("green")
                if passedCount &lt; len(preconditions) </span><span class="cov0" title="0">{
                        statusIcon = ""
                        statusColor = r.getColor("red")
                }</span>
                
                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("   %s%s :%s %s(%d/%d )%s\n", 
                        statusColor, statusIcon, r.getColor("reset"),
                        r.getColor("dim"), passedCount, len(preconditions), r.getColor("reset")))
                
                for _, detail := range preconditions </span><span class="cov0" title="0">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
        
        // Render postconditions
        <span class="cov8" title="1">if len(postconditions) &gt; 0 </span><span class="cov8" title="1">{
                passedCount := 0
                for _, detail := range postconditions </span><span class="cov8" title="1">{
                        if detail.IsPassed() </span><span class="cov8" title="1">{
                                passedCount++
                        }</span>
                }
                
                <span class="cov8" title="1">statusIcon := ""
                statusColor := r.getColor("green")
                if passedCount &lt; len(postconditions) </span><span class="cov8" title="1">{
                        statusIcon = ""
                        statusColor = r.getColor("red")
                }</span>
                
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("   %s%s :%s %s(%d/%d )%s\n", 
                        statusColor, statusIcon, r.getColor("reset"),
                        r.getColor("dim"), passedCount, len(postconditions), r.getColor("reset")))
                
                for _, detail := range postconditions </span><span class="cov8" title="1">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
}

// renderValidationDetailHuman renders a single validation detail in human format with enhanced styling
func (r *DefaultReportRenderer) renderValidationDetailHuman(output *strings.Builder, detail models.ValidationDetail, indent string) <span class="cov8" title="1">{
        icon := ""
        iconColor := r.getColor("green")
        if !detail.IsPassed() </span><span class="cov8" title="1">{
                icon = ""
                iconColor = r.getColor("red")
        }</span>
        
        // Render the main message with color coding
        <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s%s%s%s %s\n", 
                indent, iconColor, icon, r.getColor("reset"), detail.Message))
        
        // Show detailed information for failed assertions
        if !detail.IsPassed() &amp;&amp; r.config.ShowDetailedErrors </span><span class="cov8" title="1">{
                // Expression details
                if detail.Expression != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s:%s %s%s%s\n", 
                                indent, r.getColor("dim"), r.getColor("reset"),
                                r.getColor("cyan"), detail.Expression, r.getColor("reset")))
                }</span>
                
                // Expected vs Actual with enhanced formatting
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s   %s:%s %s%v%s %s(%T)%s\n", 
                        indent, r.getColor("green"), r.getColor("reset"),
                        r.getColor("bold"), detail.Expected, r.getColor("reset"),
                        r.getColor("dim"), detail.Expected, r.getColor("reset")))
                
                output.WriteString(fmt.Sprintf("%s   %s:%s %s%v%s %s(%T)%s\n", 
                        indent, r.getColor("red"), r.getColor("reset"),
                        r.getColor("bold"), detail.Actual, r.getColor("reset"),
                        r.getColor("dim"), detail.Actual, r.getColor("reset")))
                
                // Failure reason with enhanced formatting
                if detail.FailureReason != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s :%s %s\n", 
                                indent, r.getColor("yellow"), r.getColor("reset"), detail.FailureReason))
                }</span>
                
                // Context information (if available)
                <span class="cov8" title="1">if len(detail.ContextInfo) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s :%s\n", 
                                indent, r.getColor("cyan"), r.getColor("reset")))
                        
                        // Show relevant span information
                        if spanInfo, ok := detail.ContextInfo["span"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if spanName, ok := spanInfo["name"].(string); ok </span><span class="cov8" title="1">{
                                        output.WriteString(fmt.Sprintf("%s     Span : %s%s%s\n", 
                                                indent, r.getColor("cyan"), spanName, r.getColor("reset")))
                                }</span>
                                <span class="cov8" title="1">if spanID, ok := spanInfo["id"].(string); ok </span><span class="cov8" title="1">{
                                        output.WriteString(fmt.Sprintf("%s     Span ID: %s%s%s\n", 
                                                indent, r.getColor("dim"), spanID, r.getColor("reset")))
                                }</span>
                                <span class="cov8" title="1">if status, ok := spanInfo["status"].(models.SpanStatus); ok </span><span class="cov8" title="1">{
                                        statusColor := r.getColor("green")
                                        if status.Code == "ERROR" </span><span class="cov8" title="1">{
                                                statusColor = r.getColor("red")
                                        }</span>
                                        <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s     : %s%s%s", 
                                                indent, statusColor, status.Code, r.getColor("reset")))
                                        if status.Message != "" </span><span class="cov8" title="1">{
                                                output.WriteString(fmt.Sprintf(" - %s", status.Message))
                                        }</span>
                                        <span class="cov8" title="1">output.WriteString("\n")</span>
                                }
                        }
                }
                
                // Actionable suggestions with enhanced formatting
                <span class="cov8" title="1">if len(detail.Suggestions) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s :%s\n", 
                                indent, r.getColor("yellow"), r.getColor("reset")))
                        for i, suggestion := range detail.Suggestions </span><span class="cov8" title="1">{
                                output.WriteString(fmt.Sprintf("%s     %s%d.%s %s\n", 
                                        indent, r.getColor("dim"), i+1, r.getColor("reset"), suggestion))
                        }</span>
                }
                
                // Add separator for readability
                <span class="cov8" title="1">if detail.FailureReason != "" || len(detail.Suggestions) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s%s%s\n", 
                                indent, r.getColor("dim"), strings.Repeat("", 40), r.getColor("reset")))
                }</span>
        }
}

// getStatusIcon returns an icon for the given alignment status
func (r *DefaultReportRenderer) getStatusIcon(status models.AlignmentStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case models.StatusSuccess:<span class="cov8" title="1">
                return ""</span>
        case models.StatusFailed:<span class="cov8" title="1">
                return ""</span>
        case models.StatusSkipped:<span class="cov8" title="1">
                return ""</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// RenderJSON implements the ReportRenderer interface with enhanced JSON formatting and validation
func (r *DefaultReportRenderer) RenderJSON(report *models.AlignmentReport) (string, error) <span class="cov8" title="1">{
        if report == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("report cannot be nil")
        }</span>
        
        // Validate report completeness before rendering
        <span class="cov8" title="1">if err := r.validateReportCompleteness(report); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("report validation failed: %w", err)
        }</span>
        
        // Create a structured JSON output with consistent formatting
        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal report to JSON: %w", err)
        }</span>
        
        // Validate that the generated JSON is well-formed
        <span class="cov8" title="1">var testUnmarshal interface{}
        if err := json.Unmarshal(jsonData, &amp;testUnmarshal); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated JSON is malformed: %w", err)
        }</span>
        
        <span class="cov8" title="1">return string(jsonData), nil</span>
}

// validateReportCompleteness validates that the report has all required fields
func (r *DefaultReportRenderer) validateReportCompleteness(report *models.AlignmentReport) error <span class="cov8" title="1">{
        // Check if this looks like a valid AlignmentReport structure
        // This is a basic structural check - if it unmarshaled successfully but doesn't have
        // the expected fields, it's likely the wrong structure
        
        // Check for required top-level fields by checking if they have reasonable values
        // An empty/default AlignmentReport is still valid, but a completely wrong structure should fail
        
        // If Results is nil but Summary.Total &gt; 0, that's inconsistent
        if report.Results == nil &amp;&amp; report.Summary.Total &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("results is nil but summary indicates %d total specs", report.Summary.Total)
        }</span>
        
        // Validate summary exists and has consistent data
        <span class="cov8" title="1">if report.Summary.Total != len(report.Results) </span><span class="cov8" title="1">{
                return fmt.Errorf("summary total (%d) doesn't match results count (%d)", 
                        report.Summary.Total, len(report.Results))
        }</span>
        
        // Count actual statuses to verify summary accuracy
        <span class="cov8" title="1">actualSuccess := 0
        actualFailed := 0
        actualSkipped := 0
        
        for i, result := range report.Results </span><span class="cov8" title="1">{
                // Validate each result has required fields
                if result.SpecOperationID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] missing specOperationId", i)
                }</span>
                
                <span class="cov8" title="1">if !result.Status.IsValid() </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] has invalid status: %s", i, result.Status)
                }</span>
                
                // Count statuses
                <span class="cov8" title="1">switch result.Status </span>{
                case models.StatusSuccess:<span class="cov8" title="1">
                        actualSuccess++</span>
                case models.StatusFailed:<span class="cov8" title="1">
                        actualFailed++</span>
                case models.StatusSkipped:<span class="cov8" title="1">
                        actualSkipped++</span>
                }
                
                // Validate assertion counts are consistent
                <span class="cov8" title="1">if result.AssertionsTotal != result.AssertionsPassed + result.AssertionsFailed </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] assertion counts inconsistent: total=%d, passed=%d, failed=%d", 
                                i, result.AssertionsTotal, result.AssertionsPassed, result.AssertionsFailed)
                }</span>
        }
        
        // Validate summary counts match actual counts
        <span class="cov8" title="1">if report.Summary.Success != actualSuccess </span><span class="cov0" title="0">{
                return fmt.Errorf("summary success count (%d) doesn't match actual (%d)", 
                        report.Summary.Success, actualSuccess)
        }</span>
        <span class="cov8" title="1">if report.Summary.Failed != actualFailed </span><span class="cov0" title="0">{
                return fmt.Errorf("summary failed count (%d) doesn't match actual (%d)", 
                        report.Summary.Failed, actualFailed)
        }</span>
        <span class="cov8" title="1">if report.Summary.Skipped != actualSkipped </span><span class="cov0" title="0">{
                return fmt.Errorf("summary skipped count (%d) doesn't match actual (%d)", 
                        report.Summary.Skipped, actualSkipped)
        }</span>
        
        // Validate timing information
        <span class="cov8" title="1">if report.ExecutionTime &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("execution time cannot be negative: %d", report.ExecutionTime)
        }</span>
        
        <span class="cov8" title="1">if report.StartTime &gt; 0 &amp;&amp; report.EndTime &gt; 0 &amp;&amp; report.EndTime &lt; report.StartTime </span><span class="cov0" title="0">{
                return fmt.Errorf("end time (%d) cannot be before start time (%d)", 
                        report.EndTime, report.StartTime)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetJSONSchema returns the JSON schema for the alignment report
func (r *DefaultReportRenderer) GetJSONSchema() string <span class="cov8" title="1">{
        return `{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://flowspec.dev/schemas/alignment-report.json",
  "title": "FlowSpec Alignment Report",
  "description": "Schema for FlowSpec alignment verification reports",
  "type": "object",
  "required": ["summary", "results", "executionTime", "startTime", "endTime"],
  "properties": {
    "summary": {
      "type": "object",
      "required": ["total", "success", "failed", "skipped", "successRate", "failureRate", "skipRate"],
      "properties": {
        "total": {"type": "integer", "minimum": 0},
        "success": {"type": "integer", "minimum": 0},
        "failed": {"type": "integer", "minimum": 0},
        "skipped": {"type": "integer", "minimum": 0},
        "successRate": {"type": "number", "minimum": 0, "maximum": 1},
        "failureRate": {"type": "number", "minimum": 0, "maximum": 1},
        "skipRate": {"type": "number", "minimum": 0, "maximum": 1},
        "averageExecutionTime": {"type": "integer", "minimum": 0},
        "totalAssertions": {"type": "integer", "minimum": 0},
        "failedAssertions": {"type": "integer", "minimum": 0}
      }
    },
    "results": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["specOperationId", "status", "details", "executionTime"],
        "properties": {
          "specOperationId": {"type": "string", "minLength": 1},
          "status": {"type": "string", "enum": ["SUCCESS", "FAILED", "SKIPPED"]},
          "details": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["type", "expression", "expected", "actual", "message"],
              "properties": {
                "type": {"type": "string", "enum": ["precondition", "postcondition", "matching"]},
                "expression": {"type": "string"},
                "expected": {},
                "actual": {},
                "message": {"type": "string"},
                "failureReason": {"type": "string"},
                "suggestions": {"type": "array", "items": {"type": "string"}},
                "contextInfo": {"type": "object"}
              }
            }
          },
          "executionTime": {"type": "integer", "minimum": 0},
          "startTime": {"type": "integer", "minimum": 0},
          "endTime": {"type": "integer", "minimum": 0},
          "matchedSpans": {"type": "array", "items": {"type": "string"}},
          "assertionsTotal": {"type": "integer", "minimum": 0},
          "assertionsPassed": {"type": "integer", "minimum": 0},
          "assertionsFailed": {"type": "integer", "minimum": 0},
          "errorMessage": {"type": "string"}
        }
      }
    },
    "executionTime": {"type": "integer", "minimum": 0},
    "startTime": {"type": "integer", "minimum": 0},
    "endTime": {"type": "integer", "minimum": 0},
    "performanceInfo": {
      "type": "object",
      "properties": {
        "specsProcessed": {"type": "integer", "minimum": 0},
        "spansMatched": {"type": "integer", "minimum": 0},
        "assertionsEvaluated": {"type": "integer", "minimum": 0},
        "concurrentWorkers": {"type": "integer", "minimum": 1},
        "memoryUsageMB": {"type": "number", "minimum": 0},
        "processingRate": {"type": "number", "minimum": 0}
      }
    }
  }
}`
}</span>

// ValidateJSONOutput validates that the JSON output conforms to the schema
func (r *DefaultReportRenderer) ValidateJSONOutput(jsonOutput string) error <span class="cov8" title="1">{
        // Additional JSON-specific validations
        if len(jsonOutput) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("JSON output is empty")
        }</span>
        
        // First, ensure it's valid JSON
        <span class="cov8" title="1">var genericJSON map[string]interface{}
        if err := json.Unmarshal([]byte(jsonOutput), &amp;genericJSON); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("JSON is not well-formed: %w", err)
        }</span>
        
        // Check for required top-level fields that should exist in an AlignmentReport
        <span class="cov8" title="1">requiredFields := []string{"summary", "results", "executionTime", "startTime", "endTime"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if _, exists := genericJSON[field]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("JSON structure validation failed: missing required field '%s'", field)
                }</span>
        }
        
        // Try to parse as an AlignmentReport
        <span class="cov8" title="1">var report models.AlignmentReport
        if err := json.Unmarshal([]byte(jsonOutput), &amp;report); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JSON structure validation failed: cannot unmarshal as AlignmentReport: %w", err)
        }</span>
        
        // Validate the structure matches our expectations
        <span class="cov8" title="1">if err := r.validateReportCompleteness(&amp;report); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JSON structure validation failed: %w", err)
        }</span>
        
        // Just verify that it can be re-marshaled (structure is valid)
        <span class="cov8" title="1">_, err := json.MarshalIndent(genericJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format JSON for validation: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// RenderJSONWithSchema renders JSON output with optional schema inclusion
func (r *DefaultReportRenderer) RenderJSONWithSchema(report *models.AlignmentReport, includeSchema bool) (string, error) <span class="cov8" title="1">{
        jsonOutput, err := r.RenderJSON(report)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov8" title="1">if !includeSchema </span><span class="cov8" title="1">{
                return jsonOutput, nil
        }</span>
        
        // Create a wrapper object that includes both the schema and the report
        <span class="cov8" title="1">wrapper := map[string]interface{}{
                "$schema": "https://flowspec.dev/schemas/alignment-report.json",
                "report":  report,
        }
        
        wrapperJSON, err := json.MarshalIndent(wrapper, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal wrapper JSON: %w", err)
        }</span>
        
        <span class="cov8" title="1">return string(wrapperJSON), nil</span>
}

// GetExitCode implements the ReportRenderer interface
func (r *DefaultReportRenderer) GetExitCode(report *models.AlignmentReport) int <span class="cov8" title="1">{
        if report == nil </span><span class="cov8" title="1">{
                return 2 // System error
        }</span>
        
        <span class="cov8" title="1">if report.HasFailures() </span><span class="cov8" title="1">{
                return 1 // Validation failures
        }</span>
        
        <span class="cov8" title="1">return 0</span> // Success
}

// Color support methods

// getColor returns ANSI color codes if color output is enabled
func (r *DefaultReportRenderer) getColor(colorName string) string <span class="cov8" title="1">{
        if !r.config.ColorOutput </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">colors := map[string]string{
                "reset":   "\033[0m",
                "bold":    "\033[1m",
                "dim":     "\033[2m",
                "red":     "\033[31m",
                "green":   "\033[32m",
                "yellow":  "\033[33m",
                "blue":    "\033[34m",
                "magenta": "\033[35m",
                "cyan":    "\033[36m",
                "white":   "\033[37m",
        }
        
        if color, exists := colors[colorName]; exists </span><span class="cov8" title="1">{
                return color
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// getStatusColor returns the appropriate color for a given status
func (r *DefaultReportRenderer) getStatusColor(status models.AlignmentStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case models.StatusSuccess:<span class="cov8" title="1">
                return r.getColor("green")</span>
        case models.StatusFailed:<span class="cov8" title="1">
                return r.getColor("red")</span>
        case models.StatusSkipped:<span class="cov8" title="1">
                return r.getColor("yellow")</span>
        default:<span class="cov8" title="1">
                return r.getColor("reset")</span>
        }
}

// writeColoredHeader writes a colored header section
func (r *DefaultReportRenderer) writeColoredHeader(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s%s\n", 
                r.getColor("bold"), r.getColor("blue"), text, r.getColor("reset")))
}</span>

// writeColoredSection writes a colored section header
func (r *DefaultReportRenderer) writeColoredSection(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s\n", 
                r.getColor("bold"), text, r.getColor("reset")))
}</span>

// writeColoredSubsection writes a colored subsection header
func (r *DefaultReportRenderer) writeColoredSubsection(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s\n", 
                r.getColor("cyan"), text, r.getColor("reset")))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
