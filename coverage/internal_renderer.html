
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>renderer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">flowspec-cli/internal/renderer/renderer.go (86.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package renderer

import (
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "flowspec-cli/internal/models"
)

// ReportRenderer defines the interface for rendering alignment reports
type ReportRenderer interface {
        RenderHuman(report *models.AlignmentReport) (string, error)
        RenderJSON(report *models.AlignmentReport) (string, error)
        GetExitCode(report *models.AlignmentReport) int
}

// DefaultReportRenderer implements the ReportRenderer interface
type DefaultReportRenderer struct {
        config *RendererConfig
}

// RendererConfig holds configuration for the report renderer
type RendererConfig struct {
        ShowTimestamps    bool
        ShowPerformance   bool
        ShowDetailedErrors bool
        ColorOutput       bool
}

// DefaultRendererConfig returns a default renderer configuration
func DefaultRendererConfig() *RendererConfig <span class="cov8" title="1">{
        return &amp;RendererConfig{
                ShowTimestamps:    true,
                ShowPerformance:   true,
                ShowDetailedErrors: true,
                ColorOutput:       true,
        }
}</span>

// NewReportRenderer creates a new report renderer with default configuration
func NewReportRenderer() *DefaultReportRenderer <span class="cov8" title="1">{
        return &amp;DefaultReportRenderer{
                config: DefaultRendererConfig(),
        }
}</span>

// NewReportRendererWithConfig creates a new report renderer with custom configuration
func NewReportRendererWithConfig(config *RendererConfig) *DefaultReportRenderer <span class="cov8" title="1">{
        return &amp;DefaultReportRenderer{
                config: config,
        }
}</span>

// RenderHuman implements the ReportRenderer interface with enhanced formatting and color support
func (r *DefaultReportRenderer) RenderHuman(report *models.AlignmentReport) (string, error) <span class="cov8" title="1">{
        var output strings.Builder
        
        // Header with enhanced styling
        r.writeColoredHeader(&amp;output, "FlowSpec éªŒè¯æŠ¥å‘Š")
        output.WriteString("==================================================\n\n")
        
        // Summary statistics with color coding
        r.writeColoredSection(&amp;output, "ğŸ“Š æ±‡æ€»ç»Ÿè®¡")
        output.WriteString(fmt.Sprintf("  æ€»è®¡: %s%d%s ä¸ª ServiceSpec\n", 
                r.getColor("bold"), report.Summary.Total, r.getColor("reset")))
        
        // Success count with green color
        output.WriteString(fmt.Sprintf("  %sâœ… æˆåŠŸ: %s%d%s ä¸ª%s", 
                r.getColor("green"), r.getColor("bold"), report.Summary.Success, r.getColor("reset"), r.getColor("reset")))
        if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                successRate := float64(report.Summary.Success) / float64(report.Summary.Total) * 100
                output.WriteString(fmt.Sprintf(" (%.1f%%)", successRate))
        }</span>
        <span class="cov8" title="1">output.WriteString("\n")
        
        // Failed count with red color
        if report.Summary.Failed &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("  %sâŒ å¤±è´¥: %s%d%s ä¸ª%s", 
                        r.getColor("red"), r.getColor("bold"), report.Summary.Failed, r.getColor("reset"), r.getColor("reset")))
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        failureRate := float64(report.Summary.Failed) / float64(report.Summary.Total) * 100
                        output.WriteString(fmt.Sprintf(" (%.1f%%)", failureRate))
                }</span>
                <span class="cov8" title="1">output.WriteString("\n")</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("  %sâŒ å¤±è´¥: %s0%s ä¸ª%s\n", 
                        r.getColor("dim"), r.getColor("dim"), r.getColor("reset"), r.getColor("reset")))
        }</span>
        
        // Skipped count with yellow color
        <span class="cov8" title="1">if report.Summary.Skipped &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("  %sâ­ï¸  è·³è¿‡: %s%d%s ä¸ª%s", 
                        r.getColor("yellow"), r.getColor("bold"), report.Summary.Skipped, r.getColor("reset"), r.getColor("reset")))
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        skipRate := float64(report.Summary.Skipped) / float64(report.Summary.Total) * 100
                        output.WriteString(fmt.Sprintf(" (%.1f%%)", skipRate))
                }</span>
                <span class="cov8" title="1">output.WriteString("\n")</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("  %sâ­ï¸  è·³è¿‡: %s0%s ä¸ª%s\n", 
                        r.getColor("dim"), r.getColor("dim"), r.getColor("reset"), r.getColor("reset")))
        }</span>
        
        // Performance metrics with enhanced formatting
        <span class="cov8" title="1">if r.config.ShowPerformance &amp;&amp; report.PerformanceInfo.SpecsProcessed &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString("\n")
                r.writeColoredSubsection(&amp;output, "âš¡ æ€§èƒ½æŒ‡æ ‡")
                output.WriteString(fmt.Sprintf("  å¤„ç†é€Ÿåº¦: %s%.2f%s specs/ç§’\n", 
                        r.getColor("cyan"), report.PerformanceInfo.ProcessingRate, r.getColor("reset")))
                output.WriteString(fmt.Sprintf("  å†…å­˜ä½¿ç”¨: %s%.2f%s MB\n", 
                        r.getColor("cyan"), report.PerformanceInfo.MemoryUsageMB, r.getColor("reset")))
                if report.PerformanceInfo.ConcurrentWorkers &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("  å¹¶å‘å·¥ä½œçº¿ç¨‹: %s%d%s ä¸ª\n", 
                                r.getColor("cyan"), report.PerformanceInfo.ConcurrentWorkers, r.getColor("reset")))
                }</span>
                <span class="cov8" title="1">if report.Summary.TotalAssertions &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("  æ–­è¨€è¯„ä¼°: %s%d%s ä¸ª\n", 
                                r.getColor("cyan"), report.Summary.TotalAssertions, r.getColor("reset")))
                }</span>
        }
        
        // Execution time with enhanced formatting
        <span class="cov8" title="1">if r.config.ShowTimestamps </span><span class="cov8" title="1">{
                executionTime := time.Duration(report.ExecutionTime)
                output.WriteString(fmt.Sprintf("  â±ï¸  æ‰§è¡Œæ—¶é—´: %s%v%s\n", 
                        r.getColor("magenta"), executionTime, r.getColor("reset")))
                
                // Show average time per spec if meaningful
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        avgTime := time.Duration(report.Summary.AverageExecutionTime)
                        output.WriteString(fmt.Sprintf("  å¹³å‡å¤„ç†æ—¶é—´: %s%v%s/spec\n", 
                                r.getColor("magenta"), avgTime, r.getColor("reset")))
                }</span>
        }
        
        <span class="cov8" title="1">output.WriteString("\n")
        r.writeColoredSection(&amp;output, "ğŸ” è¯¦ç»†ç»“æœ")
        output.WriteString("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n")
        
        // Group results by status for better readability
        successResults := []models.AlignmentResult{}
        failedResults := []models.AlignmentResult{}
        skippedResults := []models.AlignmentResult{}
        
        for _, result := range report.Results </span><span class="cov8" title="1">{
                switch result.Status </span>{
                case models.StatusSuccess:<span class="cov8" title="1">
                        successResults = append(successResults, result)</span>
                case models.StatusFailed:<span class="cov8" title="1">
                        failedResults = append(failedResults, result)</span>
                case models.StatusSkipped:<span class="cov8" title="1">
                        skippedResults = append(skippedResults, result)</span>
                }
        }
        
        // Render failed results first (most important)
        <span class="cov8" title="1">if len(failedResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("âŒ å¤±è´¥çš„éªŒè¯ (%d ä¸ª)", len(failedResults)))
                for i, result := range failedResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(failedResults))
                        if i &lt; len(failedResults)-1 </span><span class="cov0" title="0">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Render successful results
        <span class="cov8" title="1">if len(successResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("âœ… æˆåŠŸçš„éªŒè¯ (%d ä¸ª)", len(successResults)))
                for i, result := range successResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(successResults))
                        if i &lt; len(successResults)-1 </span><span class="cov8" title="1">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Render skipped results last
        <span class="cov8" title="1">if len(skippedResults) &gt; 0 </span><span class="cov8" title="1">{
                r.writeColoredSubsection(&amp;output, fmt.Sprintf("â­ï¸  è·³è¿‡çš„éªŒè¯ (%d ä¸ª)", len(skippedResults)))
                for i, result := range skippedResults </span><span class="cov8" title="1">{
                        r.renderResultHuman(&amp;output, result, i+1, len(skippedResults))
                        if i &lt; len(skippedResults)-1 </span><span class="cov0" title="0">{
                                output.WriteString("\n")
                        }</span>
                }
                <span class="cov8" title="1">output.WriteString("\n")</span>
        }
        
        // Final summary with enhanced styling
        <span class="cov8" title="1">output.WriteString("==================================================\n")
        if report.HasFailures() </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("%séªŒè¯ç»“æœ: âŒ å¤±è´¥%s (%s%d%s ä¸ªæ–­è¨€å¤±è´¥)\n", 
                        r.getColor("red"), r.getColor("reset"), 
                        r.getColor("bold"), report.Summary.FailedAssertions, r.getColor("reset")))
                
                // Provide actionable summary for failures
                if report.Summary.FailedAssertions &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("\n%sğŸ’¡ å»ºè®®:%s\n", r.getColor("yellow"), r.getColor("reset")))
                        output.WriteString("  â€¢ æ£€æŸ¥å¤±è´¥çš„æ–­è¨€æ˜¯å¦åæ˜ äº†å®é™…çš„æœåŠ¡è¡Œä¸ºå˜åŒ–\n")
                        output.WriteString("  â€¢ éªŒè¯è½¨è¿¹æ•°æ®æ˜¯å¦åŒ…å«é¢„æœŸçš„ span å±æ€§å’ŒçŠ¶æ€\n")
                        output.WriteString("  â€¢ è€ƒè™‘æ›´æ–° ServiceSpec è§„çº¦ä»¥åŒ¹é…æ–°çš„æœåŠ¡è¡Œä¸º\n")
                }</span>
        } else<span class="cov8" title="1"> {
                output.WriteString(fmt.Sprintf("%séªŒè¯ç»“æœ: âœ… æˆåŠŸ%s (æ‰€æœ‰æ–­è¨€é€šè¿‡)\n", 
                        r.getColor("green"), r.getColor("reset")))
                
                if report.Summary.Total &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("\n%sğŸ‰ æ­å–œï¼%s æ‰€æœ‰ %d ä¸ª ServiceSpec éƒ½ç¬¦åˆé¢„æœŸè§„çº¦ã€‚\n", 
                                r.getColor("green"), r.getColor("reset"), report.Summary.Total))
                }</span>
        }
        
        <span class="cov8" title="1">return output.String(), nil</span>
}

// renderResultHuman renders a single alignment result in human format with enhanced styling
func (r *DefaultReportRenderer) renderResultHuman(output *strings.Builder, result models.AlignmentResult, index, total int) <span class="cov8" title="1">{
        // Status icon and operation ID with color coding
        statusIcon := r.getStatusIcon(result.Status)
        statusColor := r.getStatusColor(result.Status)
        
        output.WriteString(fmt.Sprintf("%s[%d/%d]%s %s %s%s%s (%s%s%s)\n", 
                r.getColor("dim"), index, total, r.getColor("reset"),
                statusIcon, 
                r.getColor("bold"), result.SpecOperationID, r.getColor("reset"),
                statusColor, result.Status, r.getColor("reset")))
        
        // Execution time with formatting
        if r.config.ShowTimestamps </span><span class="cov8" title="1">{
                executionTime := time.Duration(result.ExecutionTime)
                output.WriteString(fmt.Sprintf("   â±ï¸  æ‰§è¡Œæ—¶é—´: %s%v%s\n", 
                        r.getColor("dim"), executionTime, r.getColor("reset")))
        }</span>
        
        // Matched spans with enhanced formatting
        <span class="cov8" title="1">if len(result.MatchedSpans) &gt; 0 </span><span class="cov8" title="1">{
                output.WriteString(fmt.Sprintf("   ğŸ¯ åŒ¹é…çš„ Span: %s%s%s\n", 
                        r.getColor("cyan"), strings.Join(result.MatchedSpans, ", "), r.getColor("reset")))
        }</span> else<span class="cov8" title="1"> if result.Status == models.StatusSkipped </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %sğŸ” æœªæ‰¾åˆ°åŒ¹é…çš„ Span%s\n", 
                        r.getColor("yellow"), r.getColor("reset")))
        }</span>
        
        // Assertion summary with color coding
        <span class="cov8" title="1">if result.AssertionsTotal &gt; 0 </span><span class="cov8" title="1">{
                passedColor := r.getColor("green")
                failedColor := r.getColor("red")
                if result.AssertionsPassed == 0 </span><span class="cov8" title="1">{
                        passedColor = r.getColor("dim")
                }</span>
                <span class="cov8" title="1">if result.AssertionsFailed == 0 </span><span class="cov8" title="1">{
                        failedColor = r.getColor("dim")
                }</span>
                
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("   ğŸ“Š æ–­è¨€ç»Ÿè®¡: %s%d%s æ€»è®¡, %s%d%s é€šè¿‡, %s%d%s å¤±è´¥\n", 
                        r.getColor("bold"), result.AssertionsTotal, r.getColor("reset"),
                        passedColor, result.AssertionsPassed, r.getColor("reset"),
                        failedColor, result.AssertionsFailed, r.getColor("reset")))</span>
        }
        
        // Error message for failed results with enhanced formatting
        <span class="cov8" title="1">if result.Status == models.StatusFailed &amp;&amp; result.ErrorMessage != "" </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %sâš ï¸  é”™è¯¯ä¿¡æ¯:%s %s\n", 
                        r.getColor("red"), r.getColor("reset"), result.ErrorMessage))
        }</span>
        
        // Detailed validation results with improved readability
        <span class="cov8" title="1">if r.config.ShowDetailedErrors &amp;&amp; len(result.Details) &gt; 0 </span><span class="cov8" title="1">{
                r.renderValidationDetailsHuman(output, result.Details)
        }</span>
}

// renderValidationDetailsHuman renders validation details in human format with enhanced styling
func (r *DefaultReportRenderer) renderValidationDetailsHuman(output *strings.Builder, details []models.ValidationDetail) <span class="cov8" title="1">{
        preconditions := []models.ValidationDetail{}
        postconditions := []models.ValidationDetail{}
        matchingDetails := []models.ValidationDetail{}
        
        for _, detail := range details </span><span class="cov8" title="1">{
                switch detail.Type </span>{
                case "precondition":<span class="cov0" title="0">
                        preconditions = append(preconditions, detail)</span>
                case "postcondition":<span class="cov8" title="1">
                        postconditions = append(postconditions, detail)</span>
                case "matching":<span class="cov0" title="0">
                        matchingDetails = append(matchingDetails, detail)</span>
                }
        }
        
        // Render matching details first (if any)
        <span class="cov8" title="1">if len(matchingDetails) &gt; 0 </span><span class="cov0" title="0">{
                output.WriteString(fmt.Sprintf("   %sğŸ”— Span åŒ¹é…:%s\n", 
                        r.getColor("cyan"), r.getColor("reset")))
                for _, detail := range matchingDetails </span><span class="cov0" title="0">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
        
        // Render preconditions
        <span class="cov8" title="1">if len(preconditions) &gt; 0 </span><span class="cov0" title="0">{
                passedCount := 0
                for _, detail := range preconditions </span><span class="cov0" title="0">{
                        if detail.IsPassed() </span><span class="cov0" title="0">{
                                passedCount++
                        }</span>
                }
                
                <span class="cov0" title="0">statusIcon := "âœ…"
                statusColor := r.getColor("green")
                if passedCount &lt; len(preconditions) </span><span class="cov0" title="0">{
                        statusIcon = "âŒ"
                        statusColor = r.getColor("red")
                }</span>
                
                <span class="cov0" title="0">output.WriteString(fmt.Sprintf("   %s%s å‰ç½®æ¡ä»¶:%s %s(%d/%d é€šè¿‡)%s\n", 
                        statusColor, statusIcon, r.getColor("reset"),
                        r.getColor("dim"), passedCount, len(preconditions), r.getColor("reset")))
                
                for _, detail := range preconditions </span><span class="cov0" title="0">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
        
        // Render postconditions
        <span class="cov8" title="1">if len(postconditions) &gt; 0 </span><span class="cov8" title="1">{
                passedCount := 0
                for _, detail := range postconditions </span><span class="cov8" title="1">{
                        if detail.IsPassed() </span><span class="cov8" title="1">{
                                passedCount++
                        }</span>
                }
                
                <span class="cov8" title="1">statusIcon := "âœ…"
                statusColor := r.getColor("green")
                if passedCount &lt; len(postconditions) </span><span class="cov8" title="1">{
                        statusIcon = "âŒ"
                        statusColor = r.getColor("red")
                }</span>
                
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("   %s%s åç½®æ¡ä»¶:%s %s(%d/%d é€šè¿‡)%s\n", 
                        statusColor, statusIcon, r.getColor("reset"),
                        r.getColor("dim"), passedCount, len(postconditions), r.getColor("reset")))
                
                for _, detail := range postconditions </span><span class="cov8" title="1">{
                        r.renderValidationDetailHuman(output, detail, "     ")
                }</span>
        }
}

// renderValidationDetailHuman renders a single validation detail in human format with enhanced styling
func (r *DefaultReportRenderer) renderValidationDetailHuman(output *strings.Builder, detail models.ValidationDetail, indent string) <span class="cov8" title="1">{
        icon := "âœ…"
        iconColor := r.getColor("green")
        if !detail.IsPassed() </span><span class="cov8" title="1">{
                icon = "âŒ"
                iconColor = r.getColor("red")
        }</span>
        
        // Render the main message with color coding
        <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s%s%s%s %s\n", 
                indent, iconColor, icon, r.getColor("reset"), detail.Message))
        
        // Show detailed information for failed assertions
        if !detail.IsPassed() &amp;&amp; r.config.ShowDetailedErrors </span><span class="cov8" title="1">{
                // Expression details
                if detail.Expression != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %sè¡¨è¾¾å¼:%s %s%s%s\n", 
                                indent, r.getColor("dim"), r.getColor("reset"),
                                r.getColor("cyan"), detail.Expression, r.getColor("reset")))
                }</span>
                
                // Expected vs Actual with enhanced formatting
                <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s   %sæœŸæœ›:%s %s%v%s %s(%T)%s\n", 
                        indent, r.getColor("green"), r.getColor("reset"),
                        r.getColor("bold"), detail.Expected, r.getColor("reset"),
                        r.getColor("dim"), detail.Expected, r.getColor("reset")))
                
                output.WriteString(fmt.Sprintf("%s   %så®é™…:%s %s%v%s %s(%T)%s\n", 
                        indent, r.getColor("red"), r.getColor("reset"),
                        r.getColor("bold"), detail.Actual, r.getColor("reset"),
                        r.getColor("dim"), detail.Actual, r.getColor("reset")))
                
                // Failure reason with enhanced formatting
                if detail.FailureReason != "" </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %sğŸ’¡ å¤±è´¥åŸå› :%s %s\n", 
                                indent, r.getColor("yellow"), r.getColor("reset"), detail.FailureReason))
                }</span>
                
                // Context information (if available)
                <span class="cov8" title="1">if len(detail.ContextInfo) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %sğŸ” ä¸Šä¸‹æ–‡ä¿¡æ¯:%s\n", 
                                indent, r.getColor("cyan"), r.getColor("reset")))
                        
                        // Show relevant span information
                        if spanInfo, ok := detail.ContextInfo["span"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if spanName, ok := spanInfo["name"].(string); ok </span><span class="cov8" title="1">{
                                        output.WriteString(fmt.Sprintf("%s     Span åç§°: %s%s%s\n", 
                                                indent, r.getColor("cyan"), spanName, r.getColor("reset")))
                                }</span>
                                <span class="cov8" title="1">if spanID, ok := spanInfo["id"].(string); ok </span><span class="cov8" title="1">{
                                        output.WriteString(fmt.Sprintf("%s     Span ID: %s%s%s\n", 
                                                indent, r.getColor("dim"), spanID, r.getColor("reset")))
                                }</span>
                                <span class="cov8" title="1">if status, ok := spanInfo["status"].(models.SpanStatus); ok </span><span class="cov8" title="1">{
                                        statusColor := r.getColor("green")
                                        if status.Code == "ERROR" </span><span class="cov8" title="1">{
                                                statusColor = r.getColor("red")
                                        }</span>
                                        <span class="cov8" title="1">output.WriteString(fmt.Sprintf("%s     çŠ¶æ€: %s%s%s", 
                                                indent, statusColor, status.Code, r.getColor("reset")))
                                        if status.Message != "" </span><span class="cov8" title="1">{
                                                output.WriteString(fmt.Sprintf(" - %s", status.Message))
                                        }</span>
                                        <span class="cov8" title="1">output.WriteString("\n")</span>
                                }
                        }
                }
                
                // Actionable suggestions with enhanced formatting
                <span class="cov8" title="1">if len(detail.Suggestions) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %sğŸ’¡ å»ºè®®:%s\n", 
                                indent, r.getColor("yellow"), r.getColor("reset")))
                        for i, suggestion := range detail.Suggestions </span><span class="cov8" title="1">{
                                output.WriteString(fmt.Sprintf("%s     %s%d.%s %s\n", 
                                        indent, r.getColor("dim"), i+1, r.getColor("reset"), suggestion))
                        }</span>
                }
                
                // Add separator for readability
                <span class="cov8" title="1">if detail.FailureReason != "" || len(detail.Suggestions) &gt; 0 </span><span class="cov8" title="1">{
                        output.WriteString(fmt.Sprintf("%s   %s%s%s\n", 
                                indent, r.getColor("dim"), strings.Repeat("â”€", 40), r.getColor("reset")))
                }</span>
        }
}

// getStatusIcon returns an icon for the given alignment status
func (r *DefaultReportRenderer) getStatusIcon(status models.AlignmentStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case models.StatusSuccess:<span class="cov8" title="1">
                return "âœ…"</span>
        case models.StatusFailed:<span class="cov8" title="1">
                return "âŒ"</span>
        case models.StatusSkipped:<span class="cov8" title="1">
                return "â­ï¸"</span>
        default:<span class="cov8" title="1">
                return "â“"</span>
        }
}

// RenderJSON implements the ReportRenderer interface with enhanced JSON formatting and validation
func (r *DefaultReportRenderer) RenderJSON(report *models.AlignmentReport) (string, error) <span class="cov8" title="1">{
        if report == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("report cannot be nil")
        }</span>
        
        // Validate report completeness before rendering
        <span class="cov8" title="1">if err := r.validateReportCompleteness(report); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("report validation failed: %w", err)
        }</span>
        
        // Create a structured JSON output with consistent formatting
        <span class="cov8" title="1">jsonData, err := json.MarshalIndent(report, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal report to JSON: %w", err)
        }</span>
        
        // Validate that the generated JSON is well-formed
        <span class="cov8" title="1">var testUnmarshal interface{}
        if err := json.Unmarshal(jsonData, &amp;testUnmarshal); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("generated JSON is malformed: %w", err)
        }</span>
        
        <span class="cov8" title="1">return string(jsonData), nil</span>
}

// validateReportCompleteness validates that the report has all required fields
func (r *DefaultReportRenderer) validateReportCompleteness(report *models.AlignmentReport) error <span class="cov8" title="1">{
        // Check if this looks like a valid AlignmentReport structure
        // This is a basic structural check - if it unmarshaled successfully but doesn't have
        // the expected fields, it's likely the wrong structure
        
        // Check for required top-level fields by checking if they have reasonable values
        // An empty/default AlignmentReport is still valid, but a completely wrong structure should fail
        
        // If Results is nil but Summary.Total &gt; 0, that's inconsistent
        if report.Results == nil &amp;&amp; report.Summary.Total &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("results is nil but summary indicates %d total specs", report.Summary.Total)
        }</span>
        
        // Validate summary exists and has consistent data
        <span class="cov8" title="1">if report.Summary.Total != len(report.Results) </span><span class="cov8" title="1">{
                return fmt.Errorf("summary total (%d) doesn't match results count (%d)", 
                        report.Summary.Total, len(report.Results))
        }</span>
        
        // Count actual statuses to verify summary accuracy
        <span class="cov8" title="1">actualSuccess := 0
        actualFailed := 0
        actualSkipped := 0
        
        for i, result := range report.Results </span><span class="cov8" title="1">{
                // Validate each result has required fields
                if result.SpecOperationID == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] missing specOperationId", i)
                }</span>
                
                <span class="cov8" title="1">if !result.Status.IsValid() </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] has invalid status: %s", i, result.Status)
                }</span>
                
                // Count statuses
                <span class="cov8" title="1">switch result.Status </span>{
                case models.StatusSuccess:<span class="cov8" title="1">
                        actualSuccess++</span>
                case models.StatusFailed:<span class="cov8" title="1">
                        actualFailed++</span>
                case models.StatusSkipped:<span class="cov8" title="1">
                        actualSkipped++</span>
                }
                
                // Validate assertion counts are consistent
                <span class="cov8" title="1">if result.AssertionsTotal != result.AssertionsPassed + result.AssertionsFailed </span><span class="cov0" title="0">{
                        return fmt.Errorf("result[%d] assertion counts inconsistent: total=%d, passed=%d, failed=%d", 
                                i, result.AssertionsTotal, result.AssertionsPassed, result.AssertionsFailed)
                }</span>
        }
        
        // Validate summary counts match actual counts
        <span class="cov8" title="1">if report.Summary.Success != actualSuccess </span><span class="cov0" title="0">{
                return fmt.Errorf("summary success count (%d) doesn't match actual (%d)", 
                        report.Summary.Success, actualSuccess)
        }</span>
        <span class="cov8" title="1">if report.Summary.Failed != actualFailed </span><span class="cov0" title="0">{
                return fmt.Errorf("summary failed count (%d) doesn't match actual (%d)", 
                        report.Summary.Failed, actualFailed)
        }</span>
        <span class="cov8" title="1">if report.Summary.Skipped != actualSkipped </span><span class="cov0" title="0">{
                return fmt.Errorf("summary skipped count (%d) doesn't match actual (%d)", 
                        report.Summary.Skipped, actualSkipped)
        }</span>
        
        // Validate timing information
        <span class="cov8" title="1">if report.ExecutionTime &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("execution time cannot be negative: %d", report.ExecutionTime)
        }</span>
        
        <span class="cov8" title="1">if report.StartTime &gt; 0 &amp;&amp; report.EndTime &gt; 0 &amp;&amp; report.EndTime &lt; report.StartTime </span><span class="cov0" title="0">{
                return fmt.Errorf("end time (%d) cannot be before start time (%d)", 
                        report.EndTime, report.StartTime)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetJSONSchema returns the JSON schema for the alignment report
func (r *DefaultReportRenderer) GetJSONSchema() string <span class="cov8" title="1">{
        return `{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://flowspec.dev/schemas/alignment-report.json",
  "title": "FlowSpec Alignment Report",
  "description": "Schema for FlowSpec alignment verification reports",
  "type": "object",
  "required": ["summary", "results", "executionTime", "startTime", "endTime"],
  "properties": {
    "summary": {
      "type": "object",
      "required": ["total", "success", "failed", "skipped", "successRate", "failureRate", "skipRate"],
      "properties": {
        "total": {"type": "integer", "minimum": 0},
        "success": {"type": "integer", "minimum": 0},
        "failed": {"type": "integer", "minimum": 0},
        "skipped": {"type": "integer", "minimum": 0},
        "successRate": {"type": "number", "minimum": 0, "maximum": 1},
        "failureRate": {"type": "number", "minimum": 0, "maximum": 1},
        "skipRate": {"type": "number", "minimum": 0, "maximum": 1},
        "averageExecutionTime": {"type": "integer", "minimum": 0},
        "totalAssertions": {"type": "integer", "minimum": 0},
        "failedAssertions": {"type": "integer", "minimum": 0}
      }
    },
    "results": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["specOperationId", "status", "details", "executionTime"],
        "properties": {
          "specOperationId": {"type": "string", "minLength": 1},
          "status": {"type": "string", "enum": ["SUCCESS", "FAILED", "SKIPPED"]},
          "details": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["type", "expression", "expected", "actual", "message"],
              "properties": {
                "type": {"type": "string", "enum": ["precondition", "postcondition", "matching"]},
                "expression": {"type": "string"},
                "expected": {},
                "actual": {},
                "message": {"type": "string"},
                "failureReason": {"type": "string"},
                "suggestions": {"type": "array", "items": {"type": "string"}},
                "contextInfo": {"type": "object"}
              }
            }
          },
          "executionTime": {"type": "integer", "minimum": 0},
          "startTime": {"type": "integer", "minimum": 0},
          "endTime": {"type": "integer", "minimum": 0},
          "matchedSpans": {"type": "array", "items": {"type": "string"}},
          "assertionsTotal": {"type": "integer", "minimum": 0},
          "assertionsPassed": {"type": "integer", "minimum": 0},
          "assertionsFailed": {"type": "integer", "minimum": 0},
          "errorMessage": {"type": "string"}
        }
      }
    },
    "executionTime": {"type": "integer", "minimum": 0},
    "startTime": {"type": "integer", "minimum": 0},
    "endTime": {"type": "integer", "minimum": 0},
    "performanceInfo": {
      "type": "object",
      "properties": {
        "specsProcessed": {"type": "integer", "minimum": 0},
        "spansMatched": {"type": "integer", "minimum": 0},
        "assertionsEvaluated": {"type": "integer", "minimum": 0},
        "concurrentWorkers": {"type": "integer", "minimum": 1},
        "memoryUsageMB": {"type": "number", "minimum": 0},
        "processingRate": {"type": "number", "minimum": 0}
      }
    }
  }
}`
}</span>

// ValidateJSONOutput validates that the JSON output conforms to the schema
func (r *DefaultReportRenderer) ValidateJSONOutput(jsonOutput string) error <span class="cov8" title="1">{
        // Additional JSON-specific validations
        if len(jsonOutput) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("JSON output is empty")
        }</span>
        
        // First, ensure it's valid JSON
        <span class="cov8" title="1">var genericJSON map[string]interface{}
        if err := json.Unmarshal([]byte(jsonOutput), &amp;genericJSON); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("JSON is not well-formed: %w", err)
        }</span>
        
        // Check for required top-level fields that should exist in an AlignmentReport
        <span class="cov8" title="1">requiredFields := []string{"summary", "results", "executionTime", "startTime", "endTime"}
        for _, field := range requiredFields </span><span class="cov8" title="1">{
                if _, exists := genericJSON[field]; !exists </span><span class="cov8" title="1">{
                        return fmt.Errorf("JSON structure validation failed: missing required field '%s'", field)
                }</span>
        }
        
        // Try to parse as an AlignmentReport
        <span class="cov8" title="1">var report models.AlignmentReport
        if err := json.Unmarshal([]byte(jsonOutput), &amp;report); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JSON structure validation failed: cannot unmarshal as AlignmentReport: %w", err)
        }</span>
        
        // Validate the structure matches our expectations
        <span class="cov8" title="1">if err := r.validateReportCompleteness(&amp;report); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("JSON structure validation failed: %w", err)
        }</span>
        
        // Just verify that it can be re-marshaled (structure is valid)
        <span class="cov8" title="1">_, err := json.MarshalIndent(genericJSON, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to format JSON for validation: %w", err)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// RenderJSONWithSchema renders JSON output with optional schema inclusion
func (r *DefaultReportRenderer) RenderJSONWithSchema(report *models.AlignmentReport, includeSchema bool) (string, error) <span class="cov8" title="1">{
        jsonOutput, err := r.RenderJSON(report)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        
        <span class="cov8" title="1">if !includeSchema </span><span class="cov8" title="1">{
                return jsonOutput, nil
        }</span>
        
        // Create a wrapper object that includes both the schema and the report
        <span class="cov8" title="1">wrapper := map[string]interface{}{
                "$schema": "https://flowspec.dev/schemas/alignment-report.json",
                "report":  report,
        }
        
        wrapperJSON, err := json.MarshalIndent(wrapper, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal wrapper JSON: %w", err)
        }</span>
        
        <span class="cov8" title="1">return string(wrapperJSON), nil</span>
}

// GetExitCode implements the ReportRenderer interface
func (r *DefaultReportRenderer) GetExitCode(report *models.AlignmentReport) int <span class="cov8" title="1">{
        if report == nil </span><span class="cov8" title="1">{
                return 2 // System error
        }</span>
        
        <span class="cov8" title="1">if report.HasFailures() </span><span class="cov8" title="1">{
                return 1 // Validation failures
        }</span>
        
        <span class="cov8" title="1">return 0</span> // Success
}

// Color support methods

// getColor returns ANSI color codes if color output is enabled
func (r *DefaultReportRenderer) getColor(colorName string) string <span class="cov8" title="1">{
        if !r.config.ColorOutput </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">colors := map[string]string{
                "reset":   "\033[0m",
                "bold":    "\033[1m",
                "dim":     "\033[2m",
                "red":     "\033[31m",
                "green":   "\033[32m",
                "yellow":  "\033[33m",
                "blue":    "\033[34m",
                "magenta": "\033[35m",
                "cyan":    "\033[36m",
                "white":   "\033[37m",
        }
        
        if color, exists := colors[colorName]; exists </span><span class="cov8" title="1">{
                return color
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// getStatusColor returns the appropriate color for a given status
func (r *DefaultReportRenderer) getStatusColor(status models.AlignmentStatus) string <span class="cov8" title="1">{
        switch status </span>{
        case models.StatusSuccess:<span class="cov8" title="1">
                return r.getColor("green")</span>
        case models.StatusFailed:<span class="cov8" title="1">
                return r.getColor("red")</span>
        case models.StatusSkipped:<span class="cov8" title="1">
                return r.getColor("yellow")</span>
        default:<span class="cov8" title="1">
                return r.getColor("reset")</span>
        }
}

// writeColoredHeader writes a colored header section
func (r *DefaultReportRenderer) writeColoredHeader(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s%s\n", 
                r.getColor("bold"), r.getColor("blue"), text, r.getColor("reset")))
}</span>

// writeColoredSection writes a colored section header
func (r *DefaultReportRenderer) writeColoredSection(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s\n", 
                r.getColor("bold"), text, r.getColor("reset")))
}</span>

// writeColoredSubsection writes a colored subsection header
func (r *DefaultReportRenderer) writeColoredSubsection(output *strings.Builder, text string) <span class="cov8" title="1">{
        output.WriteString(fmt.Sprintf("%s%s%s\n", 
                r.getColor("cyan"), text, r.getColor("reset")))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
