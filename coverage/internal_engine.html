
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>engine: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">flowspec-cli/internal/engine/engine.go (91.0%)</option>
				
				<option value="file1">flowspec-cli/internal/engine/jsonlogic_evaluator.go (85.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package engine

import (
        "fmt"
        "reflect"
        "runtime"
        "strings"
        "sync"
        "time"

        "flowspec-cli/internal/models"
)

// AlignmentEngine defines the interface for aligning ServiceSpecs with trace data
type AlignmentEngine interface {
        AlignSpecsWithTrace(specs []models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentReport, error)
        AlignSingleSpec(spec models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentResult, error)
        SetEvaluator(evaluator AssertionEvaluator)
        GetEvaluator() AssertionEvaluator
}

// AssertionEvaluator defines the interface for evaluating assertions
type AssertionEvaluator interface {
        EvaluateAssertion(assertion map[string]interface{}, context *EvaluationContext) (*AssertionResult, error)
        ValidateAssertion(assertion map[string]interface{}) error
}

// EvaluationContext provides context for assertion evaluation
type EvaluationContext struct {
        Span       *models.Span
        TraceData  *models.TraceData
        Variables  map[string]interface{}
        Timestamp  time.Time
        mu         sync.RWMutex
}

// AssertionResult represents the result of evaluating an assertion
type AssertionResult struct {
        Passed      bool
        Expected    interface{}
        Actual      interface{}
        Expression  string
        Message     string
        Error       error
}

// DefaultAlignmentEngine implements the AlignmentEngine interface
type DefaultAlignmentEngine struct {
        evaluator AssertionEvaluator
        config    *EngineConfig
        mu        sync.RWMutex
}

// EngineConfig holds configuration for the alignment engine
type EngineConfig struct {
        MaxConcurrency    int           // Maximum number of concurrent alignments
        Timeout           time.Duration // Timeout for individual spec alignment
        EnableMetrics     bool          // Enable performance metrics
        StrictMode        bool          // Strict mode for validation
        SkipMissingSpans  bool          // Skip specs when corresponding spans are not found
}

// SpecMatcher handles matching ServiceSpecs to spans
type SpecMatcher struct {
        matchStrategies []MatchStrategy
        mu              sync.RWMutex
}

// MatchStrategy defines how to match specs to spans
type MatchStrategy interface {
        Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error)
        GetName() string
        GetPriority() int
}

// OperationIDMatcher matches specs to spans by operation ID
type OperationIDMatcher struct{}

// SpanNameMatcher matches specs to spans by span name
type SpanNameMatcher struct{}

// AttributeMatcher matches specs to spans by attributes
type AttributeMatcher struct {
        attributeKey string
}

// ValidationContext manages the context during validation
type ValidationContext struct {
        spec      models.ServiceSpec
        span      *models.Span
        traceData *models.TraceData
        variables map[string]interface{}
        startTime time.Time
        mu        sync.RWMutex
}

// DefaultEngineConfig returns a default engine configuration
func DefaultEngineConfig() *EngineConfig <span class="cov8" title="1">{
        return &amp;EngineConfig{
                MaxConcurrency:   4,
                Timeout:          30 * time.Second,
                EnableMetrics:    true,
                StrictMode:       false,
                SkipMissingSpans: true,
        }
}</span>

// NewAlignmentEngine creates a new alignment engine with default configuration
func NewAlignmentEngine() *DefaultAlignmentEngine <span class="cov8" title="1">{
        return NewAlignmentEngineWithConfig(DefaultEngineConfig())
}</span>

// NewAlignmentEngineWithConfig creates a new alignment engine with custom configuration
func NewAlignmentEngineWithConfig(config *EngineConfig) *DefaultAlignmentEngine <span class="cov8" title="1">{
        engine := &amp;DefaultAlignmentEngine{
                config: config,
        }
        
        // Set default JSONLogic evaluator
        engine.evaluator = NewJSONLogicEvaluator()
        
        return engine
}</span>

// NewEvaluationContext creates a new evaluation context
func NewEvaluationContext(span *models.Span, traceData *models.TraceData) *EvaluationContext <span class="cov8" title="1">{
        return &amp;EvaluationContext{
                Span:      span,
                TraceData: traceData,
                Variables: make(map[string]interface{}),
                Timestamp: time.Now(),
        }
}</span>

// NewSpecMatcher creates a new spec matcher with default strategies
func NewSpecMatcher() *SpecMatcher <span class="cov8" title="1">{
        matcher := &amp;SpecMatcher{
                matchStrategies: make([]MatchStrategy, 0),
        }
        
        // Register default matching strategies in order of priority
        matcher.AddStrategy(&amp;OperationIDMatcher{})
        matcher.AddStrategy(&amp;SpanNameMatcher{})
        matcher.AddStrategy(&amp;AttributeMatcher{attributeKey: "operation.name"})
        
        return matcher
}</span>

// NewValidationContext creates a new validation context
func NewValidationContext(spec models.ServiceSpec, span *models.Span, traceData *models.TraceData) *ValidationContext <span class="cov8" title="1">{
        return &amp;ValidationContext{
                spec:      spec,
                span:      span,
                traceData: traceData,
                variables: make(map[string]interface{}),
                startTime: time.Now(),
        }
}</span>

// AlignmentEngine methods

// AlignSpecsWithTrace implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) AlignSpecsWithTrace(specs []models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentReport, error) <span class="cov8" title="1">{
        if len(specs) == 0 </span><span class="cov8" title="1">{
                return models.NewAlignmentReport(), nil
        }</span>
        
        <span class="cov8" title="1">if traceData == nil || len(traceData.Spans) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("trace data is empty or nil")
        }</span>
        
        // Initialize report with timing information
        <span class="cov8" title="1">startTime := time.Now()
        report := models.NewAlignmentReport()
        report.StartTime = startTime.UnixNano()
        
        // Initialize performance monitoring if enabled
        var performanceInfo models.PerformanceInfo
        if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo = models.PerformanceInfo{
                        SpecsProcessed:      0,
                        SpansMatched:        0,
                        AssertionsEvaluated: 0,
                        ConcurrentWorkers:   0,
                        MemoryUsageMB:       0.0,
                        ProcessingRate:      0.0,
                }
        }</span>
        
        // Create channels for concurrent processing
        <span class="cov8" title="1">specChan := make(chan models.ServiceSpec, len(specs))
        resultChan := make(chan *models.AlignmentResult, len(specs))
        errorChan := make(chan error, len(specs))
        
        // Determine number of workers
        numWorkers := engine.config.MaxConcurrency
        if numWorkers &gt; len(specs) </span><span class="cov8" title="1">{
                numWorkers = len(specs)
        }</span>
        
        // Update performance info with worker count
        <span class="cov8" title="1">if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo.ConcurrentWorkers = numWorkers
        }</span>
        
        // Start workers
        <span class="cov8" title="1">var wg sync.WaitGroup
        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func() </span><span class="cov8" title="1">{
                        defer wg.Done()
                        engine.alignmentWorker(specChan, resultChan, errorChan, traceData)
                }</span>()
        }
        
        // Send specs to workers
        <span class="cov8" title="1">for _, spec := range specs </span><span class="cov8" title="1">{
                specChan &lt;- spec
        }</span>
        <span class="cov8" title="1">close(specChan)
        
        // Wait for workers to complete
        go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(resultChan)
                close(errorChan)
        }</span>()
        
        // Collect results and update performance metrics
        <span class="cov8" title="1">var errors []error
        spansMatched := 0
        assertionsEvaluated := 0
        
        for </span><span class="cov8" title="1">{
                select </span>{
                case result, ok := &lt;-resultChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                resultChan = nil
                        }</span> else<span class="cov8" title="1"> {
                                report.AddResult(*result)
                                
                                // Update performance metrics
                                if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                                        performanceInfo.SpecsProcessed++
                                        spansMatched += len(result.MatchedSpans)
                                        assertionsEvaluated += result.AssertionsTotal
                                }</span>
                        }
                case err, ok := &lt;-errorChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                errorChan = nil
                        }</span> else<span class="cov0" title="0"> {
                                errors = append(errors, err)
                        }</span>
                }
                
                <span class="cov8" title="1">if resultChan == nil &amp;&amp; errorChan == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        
        // Finalize report timing and performance information
        <span class="cov8" title="1">endTime := time.Now()
        report.EndTime = endTime.UnixNano()
        report.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
        
        // Complete performance information
        if engine.config.EnableMetrics </span><span class="cov8" title="1">{
                performanceInfo.SpansMatched = spansMatched
                performanceInfo.AssertionsEvaluated = assertionsEvaluated
                
                // Calculate processing rate (specs per second)
                executionSeconds := float64(report.ExecutionTime) / 1e9
                if executionSeconds &gt; 0 </span><span class="cov8" title="1">{
                        performanceInfo.ProcessingRate = float64(performanceInfo.SpecsProcessed) / executionSeconds
                }</span>
                
                // Get memory usage (simplified - in a real implementation, you'd use runtime.MemStats)
                <span class="cov8" title="1">performanceInfo.MemoryUsageMB = engine.getMemoryUsageMB()
                
                report.PerformanceInfo = performanceInfo</span>
        }
        
        // Return error if any critical errors occurred
        <span class="cov8" title="1">if len(errors) &gt; 0 &amp;&amp; len(report.Results) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("alignment failed with %d errors: %v", len(errors), errors[0])
        }</span>
        
        <span class="cov8" title="1">return report, nil</span>
}

// AlignSingleSpec implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) AlignSingleSpec(spec models.ServiceSpec, traceData *models.TraceData) (*models.AlignmentResult, error) <span class="cov8" title="1">{
        if engine.evaluator == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no assertion evaluator configured")
        }</span>
        
        <span class="cov8" title="1">startTime := time.Now()
        result := models.NewAlignmentResult(spec.OperationID)
        result.StartTime = startTime.UnixNano()
        
        // Find matching spans
        matcher := NewSpecMatcher()
        matchingSpans, err := matcher.FindMatchingSpans(spec, traceData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find matching spans: %w", err)
        }</span>
        
        <span class="cov8" title="1">if len(matchingSpans) == 0 </span><span class="cov8" title="1">{
                if engine.config.SkipMissingSpans </span><span class="cov8" title="1">{
                        result.AddValidationDetail(*models.NewValidationDetail(
                                "matching", "span_match", "found", "found", 
                                "No matching spans found for operation: "+spec.OperationID))
                        result.Status = models.StatusSkipped // Set after adding detail
                }</span> else<span class="cov0" title="0"> {
                        result.AddValidationDetail(*models.NewValidationDetail(
                                "matching", "span_match", "found", "not_found", 
                                "Required spans not found for operation: "+spec.OperationID))
                        // Status will be set to FAILED by updateStatus due to mismatch
                }</span>
                
                // Finalize timing
                <span class="cov8" title="1">endTime := time.Now()
                result.EndTime = endTime.UnixNano()
                result.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
                return result, nil</span>
        }
        
        // Record matched span IDs
        <span class="cov8" title="1">result.MatchedSpans = make([]string, len(matchingSpans))
        for i, span := range matchingSpans </span><span class="cov8" title="1">{
                result.MatchedSpans[i] = span.SpanID
        }</span>
        
        // Evaluate assertions for each matching span
        <span class="cov8" title="1">for _, span := range matchingSpans </span><span class="cov8" title="1">{
                if err := engine.evaluateSpecForSpan(spec, span, traceData, result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to evaluate spec for span %s: %w", span.SpanID, err)
                }</span>
        }
        
        // Finalize timing
        <span class="cov8" title="1">endTime := time.Now()
        result.EndTime = endTime.UnixNano()
        result.ExecutionTime = endTime.Sub(startTime).Nanoseconds()
        return result, nil</span>
}

// SetEvaluator implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) SetEvaluator(evaluator AssertionEvaluator) <span class="cov8" title="1">{
        engine.mu.Lock()
        defer engine.mu.Unlock()
        engine.evaluator = evaluator
}</span>

// GetEvaluator implements the AlignmentEngine interface
func (engine *DefaultAlignmentEngine) GetEvaluator() AssertionEvaluator <span class="cov8" title="1">{
        engine.mu.RLock()
        defer engine.mu.RUnlock()
        return engine.evaluator
}</span>

// alignmentWorker processes specs concurrently
func (engine *DefaultAlignmentEngine) alignmentWorker(specChan &lt;-chan models.ServiceSpec, resultChan chan&lt;- *models.AlignmentResult, errorChan chan&lt;- error, traceData *models.TraceData) <span class="cov8" title="1">{
        for spec := range specChan </span><span class="cov8" title="1">{
                result, err := engine.AlignSingleSpec(spec, traceData)
                if err != nil </span><span class="cov0" title="0">{
                        errorChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- result
                }</span>
        }
}

// evaluateSpecForSpan evaluates a spec against a specific span
func (engine *DefaultAlignmentEngine) evaluateSpecForSpan(spec models.ServiceSpec, span *models.Span, traceData *models.TraceData, result *models.AlignmentResult) error <span class="cov8" title="1">{
        context := NewEvaluationContext(span, traceData)
        
        // Populate context with span data
        engine.populateEvaluationContext(context, span)
        
        // Evaluate preconditions
        if len(spec.Preconditions) &gt; 0 </span><span class="cov8" title="1">{
                preconditionResult, err := engine.evaluator.EvaluateAssertion(spec.Preconditions, context)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to evaluate preconditions: %w", err)
                }</span>
                
                <span class="cov8" title="1">detail := engine.createDetailedValidationDetail(
                        "precondition", 
                        spec.Preconditions,
                        preconditionResult,
                        span,
                        context,
                )
                result.AddValidationDetail(*detail)</span>
        }
        
        // Evaluate postconditions
        <span class="cov8" title="1">if len(spec.Postconditions) &gt; 0 </span><span class="cov8" title="1">{
                postconditionResult, err := engine.evaluator.EvaluateAssertion(spec.Postconditions, context)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to evaluate postconditions: %w", err)
                }</span>
                
                <span class="cov8" title="1">detail := engine.createDetailedValidationDetail(
                        "postcondition",
                        spec.Postconditions,
                        postconditionResult,
                        span,
                        context,
                )
                result.AddValidationDetail(*detail)</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// createDetailedValidationDetail creates a detailed validation detail with enhanced error information
func (engine *DefaultAlignmentEngine) createDetailedValidationDetail(
        detailType string,
        assertion map[string]interface{},
        assertionResult *AssertionResult,
        span *models.Span,
        context *EvaluationContext,
) *models.ValidationDetail <span class="cov8" title="1">{
        // Create enhanced validation detail
        detail := &amp;models.ValidationDetail{
                Type:        detailType,
                Expression:  assertionResult.Expression,
                Expected:    assertionResult.Expected,
                Actual:      assertionResult.Actual,
                Message:     engine.generateActionableErrorMessage(detailType, assertion, assertionResult, span, context),
                SpanContext: span,
        }
        
        // Add failure analysis if assertion failed
        if !assertionResult.Passed </span><span class="cov8" title="1">{
                detail.FailureReason = engine.analyzeFailureReason(assertion, assertionResult, context)
                detail.ContextInfo = engine.extractContextInfo(span, context)
                detail.Suggestions = engine.generateSuggestions(detailType, assertion, assertionResult, span)
        }</span>
        
        <span class="cov8" title="1">return detail</span>
}

// generateActionableErrorMessage creates a detailed, actionable error message
func (engine *DefaultAlignmentEngine) generateActionableErrorMessage(
        detailType string,
        assertion map[string]interface{},
        result *AssertionResult,
        span *models.Span,
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s assertion passed: %s", 
                        strings.Title(detailType), result.Message)
        }</span>
        
        // Build detailed failure message
        <span class="cov8" title="1">var msgBuilder strings.Builder
        
        msgBuilder.WriteString(fmt.Sprintf("%s assertion failed in span '%s' (ID: %s)\n", 
                strings.Title(detailType), span.Name, span.SpanID))
        
        // Add assertion details with enhanced context
        msgBuilder.WriteString(fmt.Sprintf("Assertion: %s\n", result.Expression))
        
        // Try to extract more meaningful expected/actual values from the assertion
        expectedVal, actualVal := engine.extractMeaningfulValues(assertion, result, context)
        msgBuilder.WriteString(fmt.Sprintf("Expected: %v (type: %T)\n", expectedVal, expectedVal))
        msgBuilder.WriteString(fmt.Sprintf("Actual: %v (type: %T)\n", actualVal, actualVal))
        
        // Add JSONLogic evaluation result for reference
        msgBuilder.WriteString(fmt.Sprintf("JSONLogic Result: Expected %v, Got %v\n", result.Expected, result.Actual))
        
        // Add span context
        msgBuilder.WriteString(fmt.Sprintf("Span Status: %s", span.Status.Code))
        if span.Status.Message != "" </span><span class="cov8" title="1">{
                msgBuilder.WriteString(fmt.Sprintf(" - %s", span.Status.Message))
        }</span>
        <span class="cov8" title="1">msgBuilder.WriteString("\n")
        
        // Add relevant span attributes
        if len(span.Attributes) &gt; 0 </span><span class="cov8" title="1">{
                msgBuilder.WriteString("Relevant Span Attributes:\n")
                for key, value := range span.Attributes </span><span class="cov8" title="1">{
                        msgBuilder.WriteString(fmt.Sprintf("  %s: %v\n", key, value))
                }</span>
        }
        
        // Add trace context
        <span class="cov8" title="1">msgBuilder.WriteString(fmt.Sprintf("Trace ID: %s\n", span.TraceID))
        if span.ParentID != "" </span><span class="cov8" title="1">{
                msgBuilder.WriteString(fmt.Sprintf("Parent Span ID: %s\n", span.ParentID))
        }</span>
        
        <span class="cov8" title="1">return msgBuilder.String()</span>
}

// extractMeaningfulValues attempts to extract the actual values being compared from the assertion
func (engine *DefaultAlignmentEngine) extractMeaningfulValues(
        assertion map[string]interface{},
        result *AssertionResult,
        context *EvaluationContext,
) (interface{}, interface{}) <span class="cov8" title="1">{
        // For simple equality comparisons, try to extract the actual values
        if eqAssertion, ok := assertion["=="]; ok </span><span class="cov8" title="1">{
                if eqSlice, ok := eqAssertion.([]interface{}); ok &amp;&amp; len(eqSlice) == 2 </span><span class="cov8" title="1">{
                        // First element might be a variable reference
                        if varRef, ok := eqSlice[0].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if varName, ok := varRef["var"].(string); ok </span><span class="cov8" title="1">{
                                        if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov8" title="1">{
                                                return eqSlice[1], actualValue // expected, actual
                                        }</span>
                                        // Try with underscore conversion for JSONLogic compatibility
                                        <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                        if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[1], actualValue // expected, actual
                                        }</span>
                                }
                        }
                        // Second element might be a variable reference
                        <span class="cov8" title="1">if varRef, ok := eqSlice[1].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                        if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[0], actualValue // expected, actual
                                        }</span>
                                        // Try with underscore conversion for JSONLogic compatibility
                                        <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                        if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                return eqSlice[0], actualValue // expected, actual
                                        }</span>
                                }
                        }
                }
        }
        
        // For other comparison operators, try similar extraction
        <span class="cov8" title="1">for op, opAssertion := range assertion </span><span class="cov8" title="1">{
                switch op </span>{
                case "!=", "&gt;", "&lt;", "&gt;=", "&lt;=":<span class="cov0" title="0">
                        if opSlice, ok := opAssertion.([]interface{}); ok &amp;&amp; len(opSlice) == 2 </span><span class="cov0" title="0">{
                                // Check if first element is a variable
                                if varRef, ok := opSlice[0].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                                if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[1], actualValue // expected, actual
                                                }</span>
                                                // Try with underscore conversion
                                                <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                                if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[1], actualValue // expected, actual
                                                }</span>
                                        }
                                }
                                // Check if second element is a variable
                                <span class="cov0" title="0">if varRef, ok := opSlice[1].(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                        if varName, ok := varRef["var"].(string); ok </span><span class="cov0" title="0">{
                                                if actualValue, exists := context.GetVariable(varName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[0], actualValue // expected, actual
                                                }</span>
                                                // Try with underscore conversion
                                                <span class="cov0" title="0">safeVarName := strings.ReplaceAll(varName, ".", "_")
                                                if actualValue, exists := context.GetVariable(safeVarName); exists </span><span class="cov0" title="0">{
                                                        return opSlice[0], actualValue // expected, actual
                                                }</span>
                                        }
                                }
                        }
                }
        }
        
        // Fallback to JSONLogic result values
        <span class="cov8" title="1">return result.Expected, result.Actual</span>
}

// analyzeFailureReason analyzes why an assertion failed and provides detailed reasoning
func (engine *DefaultAlignmentEngine) analyzeFailureReason(
        assertion map[string]interface{},
        result *AssertionResult,
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        // Analyze the type of failure
        <span class="cov8" title="1">var reasons []string
        
        // Type mismatch analysis
        if result.Expected != nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                expectedType := reflect.TypeOf(result.Expected)
                actualType := reflect.TypeOf(result.Actual)
                
                if expectedType != actualType </span><span class="cov8" title="1">{
                        reasons = append(reasons, fmt.Sprintf(
                                "Type mismatch: expected %s but got %s", 
                                expectedType, actualType))
                }</span>
        }
        
        // Null/nil value analysis
        <span class="cov8" title="1">if result.Expected != nil &amp;&amp; result.Actual == nil </span><span class="cov8" title="1">{
                reasons = append(reasons, "Expected non-nil value but got nil")
        }</span> else<span class="cov8" title="1"> if result.Expected == nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                reasons = append(reasons, "Expected nil value but got non-nil")
        }</span>
        
        // Numeric comparison analysis
        <span class="cov8" title="1">if isNumeric(result.Expected) &amp;&amp; isNumeric(result.Actual) </span><span class="cov8" title="1">{
                expectedNum := toFloat64(result.Expected)
                actualNum := toFloat64(result.Actual)
                diff := actualNum - expectedNum
                
                if diff != 0 </span><span class="cov8" title="1">{
                        reasons = append(reasons, fmt.Sprintf(
                                "Numeric difference: actual value is %.2f %s than expected", 
                                abs(diff), 
                                map[bool]string{true: "greater", false: "less"}[diff &gt; 0]))
                }</span>
        }
        
        // String comparison analysis
        <span class="cov8" title="1">if expectedStr, ok := result.Expected.(string); ok </span><span class="cov8" title="1">{
                if actualStr, ok := result.Actual.(string); ok </span><span class="cov8" title="1">{
                        if len(expectedStr) != len(actualStr) </span><span class="cov8" title="1">{
                                reasons = append(reasons, fmt.Sprintf(
                                        "String length mismatch: expected %d characters, got %d", 
                                        len(expectedStr), len(actualStr)))
                        }</span>
                        
                        // Find first difference
                        <span class="cov8" title="1">minLen := min(len(expectedStr), len(actualStr))
                        for i := 0; i &lt; minLen; i++ </span><span class="cov8" title="1">{
                                if expectedStr[i] != actualStr[i] </span><span class="cov8" title="1">{
                                        reasons = append(reasons, fmt.Sprintf(
                                                "First difference at position %d: expected '%c', got '%c'", 
                                                i, expectedStr[i], actualStr[i]))
                                        break</span>
                                }
                        }
                }
        }
        
        // JSONLogic specific analysis
        <span class="cov8" title="1">if result.Error != nil </span><span class="cov0" title="0">{
                reasons = append(reasons, fmt.Sprintf("JSONLogic evaluation error: %v", result.Error))
        }</span>
        
        // Variable resolution analysis
        <span class="cov8" title="1">if len(reasons) == 0 </span><span class="cov8" title="1">{
                reasons = append(reasons, engine.analyzeVariableResolution(assertion, context))
        }</span>
        
        <span class="cov8" title="1">if len(reasons) == 0 </span><span class="cov0" title="0">{
                return "Assertion evaluated to false but specific reason could not be determined"
        }</span>
        
        <span class="cov8" title="1">return strings.Join(reasons, "; ")</span>
}

// analyzeVariableResolution analyzes potential variable resolution issues
func (engine *DefaultAlignmentEngine) analyzeVariableResolution(
        assertion map[string]interface{},
        context *EvaluationContext,
) string <span class="cov8" title="1">{
        variables := engine.extractVariablesFromAssertion(assertion)
        var issues []string
        
        for _, variable := range variables </span><span class="cov8" title="1">{
                if value, exists := context.GetVariable(variable); !exists </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Variable '%s' not found in context", variable))
                }</span> else<span class="cov8" title="1"> if value == nil </span><span class="cov8" title="1">{
                        issues = append(issues, fmt.Sprintf("Variable '%s' is nil", variable))
                }</span>
        }
        
        <span class="cov8" title="1">if len(issues) &gt; 0 </span><span class="cov8" title="1">{
                return "Variable resolution issues: " + strings.Join(issues, ", ")
        }</span>
        
        <span class="cov8" title="1">return "Unknown assertion failure reason"</span>
}

// extractVariablesFromAssertion extracts variable references from a JSONLogic assertion
func (engine *DefaultAlignmentEngine) extractVariablesFromAssertion(assertion map[string]interface{}) []string <span class="cov8" title="1">{
        var variables []string
        engine.extractVariablesRecursive(assertion, &amp;variables)
        return variables
}</span>

// extractVariablesRecursive recursively extracts variables from nested structures
func (engine *DefaultAlignmentEngine) extractVariablesRecursive(obj interface{}, variables *[]string) <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        if key == "var" </span><span class="cov8" title="1">{
                                if varName, ok := value.(string); ok </span><span class="cov8" title="1">{
                                        *variables = append(*variables, varName)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                engine.extractVariablesRecursive(value, variables)
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        engine.extractVariablesRecursive(item, variables)
                }</span>
        }
}

// extractContextInfo extracts relevant context information for debugging
func (engine *DefaultAlignmentEngine) extractContextInfo(span *models.Span, context *EvaluationContext) map[string]interface{} <span class="cov8" title="1">{
        info := make(map[string]interface{})
        
        // Span information
        info["span"] = map[string]interface{}{
                "id":         span.SpanID,
                "name":       span.Name,
                "trace_id":   span.TraceID,
                "parent_id":  span.ParentID,
                "start_time": span.StartTime,
                "end_time":   span.EndTime,
                "duration":   span.GetDuration(),
                "status":     span.Status,
                "has_error":  span.HasError(),
                "is_root":    span.IsRoot(),
        }
        
        // Available attributes
        info["attributes"] = span.Attributes
        
        // Available events
        if len(span.Events) &gt; 0 </span><span class="cov8" title="1">{
                events := make([]map[string]interface{}, len(span.Events))
                for i, event := range span.Events </span><span class="cov8" title="1">{
                        events[i] = map[string]interface{}{
                                "name":       event.Name,
                                "timestamp":  event.Timestamp,
                                "attributes": event.Attributes,
                        }
                }</span>
                <span class="cov8" title="1">info["events"] = events</span>
        }
        
        // Context variables
        <span class="cov8" title="1">info["variables"] = context.GetAllVariables()
        
        // Trace information
        if context.TraceData != nil </span><span class="cov8" title="1">{
                info["trace"] = map[string]interface{}{
                        "id":         context.TraceData.TraceID,
                        "span_count": len(context.TraceData.Spans),
                }
                
                if context.TraceData.RootSpan != nil </span><span class="cov8" title="1">{
                        info["trace"].(map[string]interface{})["root_span"] = map[string]interface{}{
                                "id":   context.TraceData.RootSpan.SpanID,
                                "name": context.TraceData.RootSpan.Name,
                        }
                }</span>
        }
        
        <span class="cov8" title="1">return info</span>
}

// generateSuggestions generates actionable suggestions for fixing assertion failures
func (engine *DefaultAlignmentEngine) generateSuggestions(
        detailType string,
        assertion map[string]interface{},
        result *AssertionResult,
        span *models.Span,
) []string <span class="cov8" title="1">{
        if result.Passed </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        <span class="cov8" title="1">var suggestions []string
        
        // Type-specific suggestions
        if result.Expected != nil &amp;&amp; result.Actual != nil </span><span class="cov8" title="1">{
                expectedType := reflect.TypeOf(result.Expected)
                actualType := reflect.TypeOf(result.Actual)
                
                if expectedType != actualType </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, fmt.Sprintf(
                                "Consider converting the actual value to %s or updating the assertion to expect %s",
                                expectedType, actualType))
                }</span>
        }
        
        // Null value suggestions
        <span class="cov8" title="1">if result.Expected != nil &amp;&amp; result.Actual == nil </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Check if the span attribute or variable exists and has a non-nil value")
        }</span>
        
        // Numeric comparison suggestions
        <span class="cov8" title="1">if isNumeric(result.Expected) &amp;&amp; isNumeric(result.Actual) </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Verify the expected numeric value or check if the span attribute contains the correct numeric data")
        }</span>
        
        // String comparison suggestions
        <span class="cov8" title="1">if _, expectedIsString := result.Expected.(string); expectedIsString </span><span class="cov8" title="1">{
                if _, actualIsString := result.Actual.(string); actualIsString </span><span class="cov8" title="1">{
                        suggestions = append(suggestions, 
                                "Check for case sensitivity, whitespace, or encoding differences in string values")
                }</span>
        }
        
        // Span-specific suggestions
        <span class="cov8" title="1">if span.HasError() </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "The span has an error status - consider checking if this affects the expected behavior")
        }</span>
        
        // General suggestions
        <span class="cov8" title="1">suggestions = append(suggestions, 
                "Review the span attributes and trace data to ensure the assertion logic matches the actual service behavior")
        
        if detailType == "precondition" </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Precondition failures may indicate that the service was called with unexpected input parameters")
        }</span> else<span class="cov8" title="1"> if detailType == "postcondition" </span><span class="cov8" title="1">{
                suggestions = append(suggestions, 
                        "Postcondition failures may indicate that the service behavior has changed or the assertion needs updating")
        }</span>
        
        <span class="cov8" title="1">return suggestions</span>
}

// populateEvaluationContext populates the evaluation context with span data
func (engine *DefaultAlignmentEngine) populateEvaluationContext(context *EvaluationContext, span *models.Span) <span class="cov8" title="1">{
        context.mu.Lock()
        defer context.mu.Unlock()
        
        // Add span attributes to context
        for key, value := range span.Attributes </span><span class="cov8" title="1">{
                // Keep original key for backward compatibility
                context.Variables[key] = value
                // Also add with underscores for JSONLogic compatibility
                safeKey := strings.ReplaceAll(key, ".", "_")
                if safeKey != key </span><span class="cov8" title="1">{
                        context.Variables[safeKey] = value
                }</span>
        }
        
        // Add span metadata
        <span class="cov8" title="1">context.Variables["span.id"] = span.SpanID
        context.Variables["span.name"] = span.Name
        context.Variables["span.start_time"] = span.StartTime
        context.Variables["span.end_time"] = span.EndTime
        context.Variables["span.duration"] = span.GetDuration()
        context.Variables["span.status.code"] = span.Status.Code
        context.Variables["span.status.message"] = span.Status.Message
        context.Variables["span.has_error"] = span.HasError()
        context.Variables["span.is_root"] = span.IsRoot()
        
        // Add trace metadata
        context.Variables["trace.id"] = span.TraceID
        if context.TraceData != nil </span><span class="cov8" title="1">{
                context.Variables["trace.span_count"] = len(context.TraceData.Spans)
                if context.TraceData.RootSpan != nil </span><span class="cov8" title="1">{
                        context.Variables["trace.root_span.id"] = context.TraceData.RootSpan.SpanID
                }</span>
        }
}

// EvaluationContext methods

// GetVariable gets a variable from the context
func (ctx *EvaluationContext) GetVariable(key string) (interface{}, bool) <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        value, exists := ctx.Variables[key]
        return value, exists
}</span>

// SetVariable sets a variable in the context
func (ctx *EvaluationContext) SetVariable(key string, value interface{}) <span class="cov8" title="1">{
        ctx.mu.Lock()
        defer ctx.mu.Unlock()
        ctx.Variables[key] = value
}</span>

// GetAllVariables returns a copy of all variables
func (ctx *EvaluationContext) GetAllVariables() map[string]interface{} <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        
        result := make(map[string]interface{})
        for key, value := range ctx.Variables </span><span class="cov8" title="1">{
                result[key] = value
        }</span>
        <span class="cov8" title="1">return result</span>
}

// SpecMatcher methods

// AddStrategy adds a matching strategy
func (sm *SpecMatcher) AddStrategy(strategy MatchStrategy) <span class="cov8" title="1">{
        sm.mu.Lock()
        defer sm.mu.Unlock()
        sm.matchStrategies = append(sm.matchStrategies, strategy)
}</span>

// FindMatchingSpans finds spans that match the given spec
func (sm *SpecMatcher) FindMatchingSpans(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        sm.mu.RLock()
        defer sm.mu.RUnlock()
        
        // Try each strategy in order of priority
        for _, strategy := range sm.matchStrategies </span><span class="cov8" title="1">{
                spans, err := strategy.Match(spec, traceData)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Try next strategy
                }
                
                <span class="cov8" title="1">if len(spans) &gt; 0 </span><span class="cov8" title="1">{
                        return spans, nil
                }</span>
        }
        
        // No matching spans found
        <span class="cov8" title="1">return []*models.Span{}, nil</span>
}

// MatchStrategy implementations

// OperationIDMatcher methods

// Match implements the MatchStrategy interface
func (matcher *OperationIDMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if operationID, ok := span.Attributes["operation.id"].(string); ok </span><span class="cov8" title="1">{
                        if operationID == spec.OperationID </span><span class="cov8" title="1">{
                                matchingSpans = append(matchingSpans, span)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *OperationIDMatcher) GetName() string <span class="cov8" title="1">{
        return "operation_id"
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *OperationIDMatcher) GetPriority() int <span class="cov8" title="1">{
        return 100 // Highest priority
}</span>

// SpanNameMatcher methods

// Match implements the MatchStrategy interface
func (matcher *SpanNameMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        // Try to match by span name (use operation ID as span name)
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if span.Name == spec.OperationID </span><span class="cov8" title="1">{
                        matchingSpans = append(matchingSpans, span)
                }</span>
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *SpanNameMatcher) GetName() string <span class="cov8" title="1">{
        return "span_name"
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *SpanNameMatcher) GetPriority() int <span class="cov8" title="1">{
        return 80 // High priority
}</span>

// AttributeMatcher methods

// Match implements the MatchStrategy interface
func (matcher *AttributeMatcher) Match(spec models.ServiceSpec, traceData *models.TraceData) ([]*models.Span, error) <span class="cov8" title="1">{
        var matchingSpans []*models.Span
        
        for _, span := range traceData.Spans </span><span class="cov8" title="1">{
                if value, ok := span.Attributes[matcher.attributeKey].(string); ok </span><span class="cov8" title="1">{
                        if value == spec.OperationID </span><span class="cov8" title="1">{
                                matchingSpans = append(matchingSpans, span)
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return matchingSpans, nil</span>
}

// GetName implements the MatchStrategy interface
func (matcher *AttributeMatcher) GetName() string <span class="cov8" title="1">{
        return fmt.Sprintf("attribute_%s", matcher.attributeKey)
}</span>

// GetPriority implements the MatchStrategy interface
func (matcher *AttributeMatcher) GetPriority() int <span class="cov8" title="1">{
        return 60 // Medium priority
}</span>

// ValidationContext methods

// GetSpec returns the spec being validated
func (ctx *ValidationContext) GetSpec() models.ServiceSpec <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.spec
}</span>

// GetSpan returns the span being validated
func (ctx *ValidationContext) GetSpan() *models.Span <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.span
}</span>

// GetTraceData returns the trace data
func (ctx *ValidationContext) GetTraceData() *models.TraceData <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return ctx.traceData
}</span>

// GetElapsedTime returns the elapsed time since validation started
func (ctx *ValidationContext) GetElapsedTime() time.Duration <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        return time.Since(ctx.startTime)
}</span>

// SetVariable sets a variable in the validation context
func (ctx *ValidationContext) SetVariable(key string, value interface{}) <span class="cov8" title="1">{
        ctx.mu.Lock()
        defer ctx.mu.Unlock()
        ctx.variables[key] = value
}</span>

// GetVariable gets a variable from the validation context
func (ctx *ValidationContext) GetVariable(key string) (interface{}, bool) <span class="cov8" title="1">{
        ctx.mu.RLock()
        defer ctx.mu.RUnlock()
        value, exists := ctx.variables[key]
        return value, exists
}</span>

// Utility functions

// isNumeric checks if a value is numeric
func isNumeric(value interface{}) bool <span class="cov8" title="1">{
        switch value.(type) </span>{
        case int, int8, int16, int32, int64:<span class="cov8" title="1">
                return true</span>
        case uint, uint8, uint16, uint32, uint64:<span class="cov8" title="1">
                return true</span>
        case float32, float64:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// toFloat64 converts a numeric value to float64
func toFloat64(value interface{}) float64 <span class="cov8" title="1">{
        switch v := value.(type) </span>{
        case int:<span class="cov8" title="1">
                return float64(v)</span>
        case int8:<span class="cov8" title="1">
                return float64(v)</span>
        case int16:<span class="cov8" title="1">
                return float64(v)</span>
        case int32:<span class="cov8" title="1">
                return float64(v)</span>
        case int64:<span class="cov8" title="1">
                return float64(v)</span>
        case uint:<span class="cov8" title="1">
                return float64(v)</span>
        case uint8:<span class="cov8" title="1">
                return float64(v)</span>
        case uint16:<span class="cov8" title="1">
                return float64(v)</span>
        case uint32:<span class="cov8" title="1">
                return float64(v)</span>
        case uint64:<span class="cov8" title="1">
                return float64(v)</span>
        case float32:<span class="cov8" title="1">
                return float64(v)</span>
        case float64:<span class="cov8" title="1">
                return v</span>
        default:<span class="cov8" title="1">
                return 0</span>
        }
}

// abs returns the absolute value of a float64
func abs(x float64) float64 <span class="cov8" title="1">{
        if x &lt; 0 </span><span class="cov8" title="1">{
                return -x
        }</span>
        <span class="cov8" title="1">return x</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// getMemoryUsageMB returns the current memory usage in MB
func (engine *DefaultAlignmentEngine) getMemoryUsageMB() float64 <span class="cov8" title="1">{
        var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)
        // Return allocated memory in MB
        return float64(m.Alloc) / 1024 / 1024
}</span>

// ValidateEngineConfig validates the engine configuration
func ValidateEngineConfig(config *EngineConfig) error <span class="cov8" title="1">{
        if config.MaxConcurrency &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxConcurrency must be positive, got %d", config.MaxConcurrency)
        }</span>
        
        <span class="cov8" title="1">if config.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Timeout must be positive, got %s", config.Timeout)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package engine

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
        "time"

        "github.com/diegoholiveira/jsonlogic/v3"
)

// JSONLogicEvaluator implements the AssertionEvaluator interface using JSONLogic
type JSONLogicEvaluator struct {
        config *JSONLogicConfig
}

// JSONLogicConfig holds configuration for JSONLogic evaluation
type JSONLogicConfig struct {
        MaxDepth         int           // Maximum recursion depth for expressions
        Timeout          time.Duration // Timeout for individual expression evaluation
        StrictMode       bool          // Strict mode for type checking
        AllowedOperators []string      // List of allowed JSONLogic operators (empty = all allowed)
        SandboxMode      bool          // Enable sandbox mode for security
}

// DefaultJSONLogicConfig returns a default configuration for JSONLogic evaluation
func DefaultJSONLogicConfig() *JSONLogicConfig <span class="cov8" title="1">{
        return &amp;JSONLogicConfig{
                MaxDepth:         10,
                Timeout:          5 * time.Second,
                StrictMode:       false,
                AllowedOperators: []string{}, // Allow all operators by default
                SandboxMode:      true,
        }
}</span>

// NewJSONLogicEvaluator creates a new JSONLogic evaluator with default configuration
func NewJSONLogicEvaluator() *JSONLogicEvaluator <span class="cov8" title="1">{
        return NewJSONLogicEvaluatorWithConfig(DefaultJSONLogicConfig())
}</span>

// NewJSONLogicEvaluatorWithConfig creates a new JSONLogic evaluator with custom configuration
func NewJSONLogicEvaluatorWithConfig(config *JSONLogicConfig) *JSONLogicEvaluator <span class="cov8" title="1">{
        return &amp;JSONLogicEvaluator{
                config: config,
        }
}</span>

// EvaluateAssertion implements the AssertionEvaluator interface
func (evaluator *JSONLogicEvaluator) EvaluateAssertion(assertion map[string]interface{}, context *EvaluationContext) (*AssertionResult, error) <span class="cov8" title="1">{
        if assertion == nil || len(assertion) == 0 </span><span class="cov8" title="1">{
                return &amp;AssertionResult{
                        Passed:     true,
                        Expected:   true,
                        Actual:     true,
                        Expression: "empty_assertion",
                        Message:    "Empty assertion always passes",
                }, nil
        }</span>

        // Build evaluation data from context
        <span class="cov8" title="1">data, err := evaluator.buildEvaluationData(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build evaluation data: %w", err)
        }</span>

        // Validate assertion before evaluation if in strict mode
        <span class="cov8" title="1">if evaluator.config.StrictMode </span><span class="cov0" title="0">{
                if err := evaluator.ValidateAssertion(assertion); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("assertion validation failed: %w", err)
                }</span>
        }

        // Apply JSONLogic with timeout protection
        <span class="cov8" title="1">result, err := evaluator.applyWithTimeout(assertion, data)
        if err != nil </span><span class="cov8" title="1">{
                assertionJSON, _ := json.Marshal(assertion)
                return &amp;AssertionResult{
                        Passed:     false,
                        Expected:   true,
                        Actual:     false,
                        Expression: string(assertionJSON),
                        Message:    fmt.Sprintf("JSONLogic evaluation failed: %v", err),
                        Error:      err,
                }, nil
        }</span>

        // Convert result to boolean
        <span class="cov8" title="1">passed := evaluator.convertToBool(result)

        assertionJSON, _ := json.Marshal(assertion)
        return &amp;AssertionResult{
                Passed:     passed,
                Expected:   true,
                Actual:     result,
                Expression: string(assertionJSON),
                Message:    evaluator.buildResultMessage(passed, assertion, result),
        }, nil</span>
}

// ValidateAssertion implements the AssertionEvaluator interface
func (evaluator *JSONLogicEvaluator) ValidateAssertion(assertion map[string]interface{}) error <span class="cov8" title="1">{
        if assertion == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("assertion cannot be nil")
        }</span>

        // Check for allowed operators if configured
        <span class="cov8" title="1">if len(evaluator.config.AllowedOperators) &gt; 0 </span><span class="cov8" title="1">{
                if err := evaluator.validateOperators(assertion, evaluator.config.AllowedOperators); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("operator validation failed: %w", err)
                }</span>
        }

        // Check maximum depth
        <span class="cov8" title="1">if err := evaluator.validateDepth(assertion, 0, evaluator.config.MaxDepth); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("depth validation failed: %w", err)
        }</span>

        // Try to marshal to JSON to ensure it's valid
        <span class="cov8" title="1">_, err := json.Marshal(assertion)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("assertion is not valid JSON: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BuildEvaluationData builds the data context for JSONLogic evaluation (exported for testing)
func (evaluator *JSONLogicEvaluator) BuildEvaluationData(context *EvaluationContext) (map[string]interface{}, error) <span class="cov0" title="0">{
        return evaluator.buildEvaluationData(context)
}</span>

// buildEvaluationData builds the data context for JSONLogic evaluation
func (evaluator *JSONLogicEvaluator) buildEvaluationData(context *EvaluationContext) (map[string]interface{}, error) <span class="cov8" title="1">{
        if context == nil </span><span class="cov8" title="1">{
                return map[string]interface{}{}, nil
        }</span>

        <span class="cov8" title="1">data := make(map[string]interface{})

        // Add span data if available
        if context.Span != nil </span><span class="cov8" title="1">{
                span := context.Span
                
                // Span basic information
                data["span"] = map[string]interface{}{
                        "id":         span.SpanID,
                        "name":       span.Name,
                        "trace_id":   span.TraceID,
                        "parent_id":  span.ParentID,
                        "start_time": span.StartTime,
                        "end_time":   span.EndTime,
                        "duration":   span.GetDuration(),
                        "status": map[string]interface{}{
                                "code":    span.Status.Code,
                                "message": span.Status.Message,
                        },
                        "has_error": span.HasError(),
                        "is_root":   span.IsRoot(),
                }

                // Add span attributes directly to root level for easier access
                // Replace dots with underscores to avoid JSONLogic property access issues
                for key, value := range span.Attributes </span><span class="cov8" title="1">{
                        // Keep original key for backward compatibility
                        data[key] = value
                        // Also add with underscores for JSONLogic compatibility
                        safeKey := strings.ReplaceAll(key, ".", "_")
                        if safeKey != key </span><span class="cov8" title="1">{
                                data[safeKey] = value
                        }</span>
                }

                // Add span attributes under "attributes" namespace as well
                <span class="cov8" title="1">data["attributes"] = span.Attributes

                // Add span events
                if len(span.Events) &gt; 0 </span><span class="cov8" title="1">{
                        events := make([]map[string]interface{}, len(span.Events))
                        for i, event := range span.Events </span><span class="cov8" title="1">{
                                events[i] = map[string]interface{}{
                                        "name":       event.Name,
                                        "timestamp":  event.Timestamp,
                                        "attributes": event.Attributes,
                                }
                        }</span>
                        <span class="cov8" title="1">data["events"] = events</span>
                }
        }

        // Add trace data if available
        <span class="cov8" title="1">if context.TraceData != nil </span><span class="cov8" title="1">{
                traceData := context.TraceData
                data["trace"] = map[string]interface{}{
                        "id":         traceData.TraceID,
                        "span_count": len(traceData.Spans),
                }

                if traceData.RootSpan != nil </span><span class="cov8" title="1">{
                        data["trace"].(map[string]interface{})["root_span"] = map[string]interface{}{
                                "id":   traceData.RootSpan.SpanID,
                                "name": traceData.RootSpan.Name,
                        }
                }</span>
        }

        // Add context variables
        <span class="cov8" title="1">allVars := context.GetAllVariables()
        for key, value := range allVars </span><span class="cov8" title="1">{
                // Avoid overwriting existing keys, use "vars" namespace
                if _, exists := data[key]; !exists </span><span class="cov8" title="1">{
                        data[key] = value
                }</span>
        }

        // Add variables under "vars" namespace as well
        <span class="cov8" title="1">data["vars"] = allVars

        // Add evaluation metadata
        data["_meta"] = map[string]interface{}{
                "timestamp":    context.Timestamp,
                "evaluator":    "jsonlogic",
                "version":      "1.0",
                "strict_mode":  evaluator.config.StrictMode,
                "sandbox_mode": evaluator.config.SandboxMode,
        }

        return data, nil</span>
}

// applyWithTimeout applies JSONLogic with timeout protection
func (evaluator *JSONLogicEvaluator) applyWithTimeout(rule interface{}, data interface{}) (interface{}, error) <span class="cov8" title="1">{
        if evaluator.config.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                // No timeout, apply directly
                return jsonlogic.ApplyInterface(rule, data)
        }</span>

        // Use channel to implement timeout
        <span class="cov8" title="1">resultChan := make(chan interface{}, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                errorChan &lt;- fmt.Errorf("JSONLogic evaluation panicked: %v", r)
                        }</span>
                }()

                <span class="cov8" title="1">result, err := jsonlogic.ApplyInterface(rule, data)
                if err != nil </span><span class="cov8" title="1">{
                        errorChan &lt;- err
                }</span> else<span class="cov8" title="1"> {
                        resultChan &lt;- result
                }</span>
        }()

        <span class="cov8" title="1">select </span>{
        case result := &lt;-resultChan:<span class="cov8" title="1">
                return result, nil</span>
        case err := &lt;-errorChan:<span class="cov8" title="1">
                return nil, err</span>
        case &lt;-time.After(evaluator.config.Timeout):<span class="cov0" title="0">
                return nil, fmt.Errorf("JSONLogic evaluation timed out after %v", evaluator.config.Timeout)</span>
        }
}

// convertToBool converts JSONLogic result to boolean
func (evaluator *JSONLogicEvaluator) convertToBool(result interface{}) bool <span class="cov8" title="1">{
        if result == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">switch v := result.(type) </span>{
        case bool:<span class="cov8" title="1">
                return v</span>
        case int:<span class="cov8" title="1">
                return v != 0</span>
        case int64:<span class="cov8" title="1">
                return v != 0</span>
        case float64:<span class="cov8" title="1">
                return v != 0.0</span>
        case string:<span class="cov8" title="1">
                return v != ""</span>
        case []interface{}:<span class="cov8" title="1">
                return len(v) &gt; 0</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return len(v) &gt; 0</span>
        default:<span class="cov0" title="0">
                // Use reflection for other types
                rv := reflect.ValueOf(result)
                switch rv.Kind() </span>{
                case reflect.Bool:<span class="cov0" title="0">
                        return rv.Bool()</span>
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                        return rv.Int() != 0</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                        return rv.Uint() != 0</span>
                case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                        return rv.Float() != 0.0</span>
                case reflect.String:<span class="cov0" title="0">
                        return rv.String() != ""</span>
                case reflect.Slice, reflect.Array, reflect.Map:<span class="cov0" title="0">
                        return rv.Len() &gt; 0</span>
                case reflect.Ptr, reflect.Interface:<span class="cov0" title="0">
                        return !rv.IsNil()</span>
                default:<span class="cov0" title="0">
                        return true</span> // Non-zero values are truthy
                }
        }
}

// buildResultMessage builds a descriptive message for the assertion result
func (evaluator *JSONLogicEvaluator) buildResultMessage(passed bool, assertion map[string]interface{}, result interface{}) string <span class="cov8" title="1">{
        if passed </span><span class="cov8" title="1">{
                return fmt.Sprintf("Assertion passed: %v evaluated to %v", assertion, result)
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("Assertion failed: %v evaluated to %v (expected truthy value)", assertion, result)
        }</span>
}

// validateOperators validates that only allowed operators are used
func (evaluator *JSONLogicEvaluator) validateOperators(assertion map[string]interface{}, allowedOps []string) error <span class="cov8" title="1">{
        allowedSet := make(map[string]bool)
        for _, op := range allowedOps </span><span class="cov8" title="1">{
                allowedSet[op] = true
        }</span>

        <span class="cov8" title="1">return evaluator.validateOperatorsRecursive(assertion, allowedSet)</span>
}

// validateOperatorsRecursive recursively validates operators
func (evaluator *JSONLogicEvaluator) validateOperatorsRecursive(obj interface{}, allowedOps map[string]bool) error <span class="cov8" title="1">{
        switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for key, value := range v </span><span class="cov8" title="1">{
                        // Check if key is an operator
                        if strings.Contains(key, ".") || len(allowedOps) &gt; 0 </span><span class="cov8" title="1">{
                                if !allowedOps[key] </span><span class="cov8" title="1">{
                                        return fmt.Errorf("operator '%s' is not allowed", key)
                                }</span>
                        }
                        
                        // Recursively validate nested objects
                        <span class="cov8" title="1">if err := evaluator.validateOperatorsRecursive(value, allowedOps); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateOperatorsRecursive(item, allowedOps); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov8" title="1">return nil</span>
}

// validateDepth validates that the assertion doesn't exceed maximum depth
func (evaluator *JSONLogicEvaluator) validateDepth(obj interface{}, currentDepth, maxDepth int) error <span class="cov8" title="1">{
        if currentDepth &gt; maxDepth </span><span class="cov8" title="1">{
                return fmt.Errorf("assertion exceeds maximum depth of %d", maxDepth)
        }</span>

        <span class="cov8" title="1">switch v := obj.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for _, value := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateDepth(value, currentDepth+1, maxDepth); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        case []interface{}:<span class="cov8" title="1">
                for _, item := range v </span><span class="cov8" title="1">{
                        if err := evaluator.validateDepth(item, currentDepth+1, maxDepth); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// GetConfig returns the current configuration
func (evaluator *JSONLogicEvaluator) GetConfig() *JSONLogicConfig <span class="cov8" title="1">{
        return evaluator.config
}</span>

// SetConfig updates the configuration
func (evaluator *JSONLogicEvaluator) SetConfig(config *JSONLogicConfig) <span class="cov8" title="1">{
        evaluator.config = config
}</span>

// ValidateConfig validates the JSONLogic configuration
func ValidateJSONLogicConfig(config *JSONLogicConfig) error <span class="cov8" title="1">{
        if config.MaxDepth &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("MaxDepth must be positive, got %d", config.MaxDepth)
        }</span>

        <span class="cov8" title="1">if config.Timeout &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("Timeout cannot be negative, got %s", config.Timeout)
        }</span>

        <span class="cov8" title="1">return nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
