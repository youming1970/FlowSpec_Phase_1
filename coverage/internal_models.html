
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>models: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">flowspec-cli/internal/models/servicespec.go (93.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package models

import (
        "encoding/json"
        "fmt"
)

// ServiceSpec represents a service specification with preconditions and postconditions
type ServiceSpec struct {
        OperationID    string                 `json:"operationId"`
        Description    string                 `json:"description"`
        Preconditions  map[string]interface{} `json:"preconditions"`
        Postconditions map[string]interface{} `json:"postconditions"`
        SourceFile     string                 `json:"sourceFile"`
        LineNumber     int                    `json:"lineNumber"`
}

// ParseResult contains the results of parsing ServiceSpecs from source files
type ParseResult struct {
        Specs   []ServiceSpec          `json:"specs"`
        Errors  []ParseError           `json:"errors"`
        Metrics map[string]interface{} `json:"metrics,omitempty"`
}

// ParseError represents an error that occurred during parsing
type ParseError struct {
        File    string `json:"file"`
        Line    int    `json:"line"`
        Message string `json:"message"`
}

// Validate checks if the ServiceSpec has all required fields
func (s *ServiceSpec) Validate() error <span class="cov8" title="1">{
        if s.OperationID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("operationId is required")
        }</span>
        <span class="cov8" title="1">if s.Description == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("description is required")
        }</span>
        <span class="cov8" title="1">if s.SourceFile == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("sourceFile is required")
        }</span>
        <span class="cov8" title="1">if s.LineNumber &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("lineNumber must be positive")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ToJSON serializes the ServiceSpec to JSON
func (s *ServiceSpec) ToJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(s)
}</span>

// FromJSON deserializes JSON data into a ServiceSpec
func (s *ServiceSpec) FromJSON(data []byte) error <span class="cov8" title="1">{
        return json.Unmarshal(data, s)
}</span>

// String returns a string representation of the ServiceSpec
func (s *ServiceSpec) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ServiceSpec{OperationID: %s, Description: %s, SourceFile: %s, LineNumber: %d}",
                s.OperationID, s.Description, s.SourceFile, s.LineNumber)
}</span>

// Error returns a string representation of the ParseError
func (e *ParseError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d: %s", e.File, e.Line, e.Message)
}</span>

// Trace-related data structures

// TraceData represents a complete trace with all its spans organized for efficient querying
type TraceData struct {
        TraceID   string             `json:"traceId"`
        RootSpan  *Span             `json:"rootSpan"`
        Spans     map[string]*Span  `json:"spans"`
        SpanTree  *SpanNode         `json:"spanTree"`
}

// Span represents a single span in an OpenTelemetry trace
type Span struct {
        SpanID     string                 `json:"spanId"`
        TraceID    string                 `json:"traceId"`
        ParentID   string                 `json:"parentSpanId,omitempty"`
        Name       string                 `json:"name"`
        StartTime  int64                  `json:"startTime"`  // Unix timestamp in nanoseconds
        EndTime    int64                  `json:"endTime"`    // Unix timestamp in nanoseconds
        Status     SpanStatus             `json:"status"`
        Attributes map[string]interface{} `json:"attributes"`
        Events     []SpanEvent            `json:"events"`
}

// SpanStatus represents the status of a span
type SpanStatus struct {
        Code    string `json:"code"`    // "OK", "ERROR", "TIMEOUT"
        Message string `json:"message"`
}

// SpanEvent represents an event within a span
type SpanEvent struct {
        Name       string                 `json:"name"`
        Timestamp  int64                  `json:"timestamp"` // Unix timestamp in nanoseconds
        Attributes map[string]interface{} `json:"attributes"`
}

// SpanNode represents a node in the span tree structure
type SpanNode struct {
        Span     *Span      `json:"span"`
        Children []*SpanNode `json:"children"`
}

// BuildSpanTree constructs a hierarchical tree structure from the spans in TraceData
func (td *TraceData) BuildSpanTree() error <span class="cov8" title="1">{
        if len(td.Spans) == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("no spans available to build tree")
        }</span>

        // Find root span (span with no parent)
        <span class="cov8" title="1">var rootSpan *Span
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.ParentID == "" </span><span class="cov8" title="1">{
                        rootSpan = span
                        break</span>
                }
        }

        <span class="cov8" title="1">if rootSpan == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("no root span found")
        }</span>

        <span class="cov8" title="1">td.RootSpan = rootSpan
        td.SpanTree = &amp;SpanNode{
                Span:     rootSpan,
                Children: []*SpanNode{},
        }

        // Build the tree recursively
        td.buildSpanTreeRecursive(td.SpanTree)
        return nil</span>
}

// buildSpanTreeRecursive recursively builds the span tree
func (td *TraceData) buildSpanTreeRecursive(node *SpanNode) <span class="cov8" title="1">{
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.ParentID == node.Span.SpanID </span><span class="cov8" title="1">{
                        childNode := &amp;SpanNode{
                                Span:     span,
                                Children: []*SpanNode{},
                        }
                        node.Children = append(node.Children, childNode)
                        td.buildSpanTreeRecursive(childNode)
                }</span>
        }
}

// GetDuration returns the duration of the span in nanoseconds
func (s *Span) GetDuration() int64 <span class="cov8" title="1">{
        return s.EndTime - s.StartTime
}</span>

// IsRoot returns true if this span is a root span (has no parent)
func (s *Span) IsRoot() bool <span class="cov8" title="1">{
        return s.ParentID == ""
}</span>

// HasError returns true if the span has an error status
func (s *Span) HasError() bool <span class="cov8" title="1">{
        return s.Status.Code == "ERROR"
}</span>

// GetAttribute returns the value of a span attribute, or nil if not found
func (s *Span) GetAttribute(key string) interface{} <span class="cov8" title="1">{
        if s.Attributes == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return s.Attributes[key]</span>
}

// AddEvent adds an event to the span
func (s *Span) AddEvent(event SpanEvent) <span class="cov8" title="1">{
        if s.Events == nil </span><span class="cov8" title="1">{
                s.Events = []SpanEvent{}
        }</span>
        <span class="cov8" title="1">s.Events = append(s.Events, event)</span>
}

// String returns a string representation of the Span
func (s *Span) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Span{SpanID: %s, TraceID: %s, Name: %s, Status: %s}",
                s.SpanID, s.TraceID, s.Name, s.Status.Code)
}</span>

// GetDepth returns the depth of this node in the span tree (root = 0)
func (sn *SpanNode) GetDepth() int <span class="cov0" title="0">{
        depth := 0
        // This would need to be calculated from the tree structure
        // For now, we'll implement a simple version
        return depth
}</span>

// GetChildCount returns the number of direct children
func (sn *SpanNode) GetChildCount() int <span class="cov8" title="1">{
        return len(sn.Children)
}</span>

// GetTotalDescendants returns the total number of descendants (children + grandchildren + ...)
func (sn *SpanNode) GetTotalDescendants() int <span class="cov8" title="1">{
        total := len(sn.Children)
        for _, child := range sn.Children </span><span class="cov8" title="1">{
                total += child.GetTotalDescendants()
        }</span>
        <span class="cov8" title="1">return total</span>
}

// FindSpanByID searches for a span by ID in the trace data
func (td *TraceData) FindSpanByID(spanID string) *Span <span class="cov8" title="1">{
        return td.Spans[spanID]
}</span>

// FindSpansByName searches for spans by name in the trace data
func (td *TraceData) FindSpansByName(name string) []*Span <span class="cov8" title="1">{
        var result []*Span
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                if span.Name == name </span><span class="cov8" title="1">{
                        result = append(result, span)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// GetAllSpans returns all spans in the trace as a slice
func (td *TraceData) GetAllSpans() []*Span <span class="cov8" title="1">{
        spans := make([]*Span, 0, len(td.Spans))
        for _, span := range td.Spans </span><span class="cov8" title="1">{
                spans = append(spans, span)
        }</span>
        <span class="cov8" title="1">return spans</span>
}

// AlignmentReport-related data structures

// AlignmentReport represents the complete report of alignment verification
type AlignmentReport struct {
        Summary         AlignmentSummary  `json:"summary"`
        Results         []AlignmentResult `json:"results"`
        ExecutionTime   int64             `json:"executionTime"`   // Total execution time in nanoseconds
        StartTime       int64             `json:"startTime"`       // Start timestamp in Unix nanoseconds
        EndTime         int64             `json:"endTime"`         // End timestamp in Unix nanoseconds
        PerformanceInfo PerformanceInfo   `json:"performanceInfo"` // Performance monitoring data
}

// AlignmentSummary provides summary statistics for the alignment report
type AlignmentSummary struct {
        Total              int     `json:"total"`
        Success            int     `json:"success"`
        Failed             int     `json:"failed"`
        Skipped            int     `json:"skipped"`
        SuccessRate        float64 `json:"successRate"`        // Success rate as percentage (0.0 to 1.0)
        FailureRate        float64 `json:"failureRate"`        // Failure rate as percentage (0.0 to 1.0)
        SkipRate           float64 `json:"skipRate"`           // Skip rate as percentage (0.0 to 1.0)
        AverageExecutionTime int64 `json:"averageExecutionTime"` // Average execution time per spec in nanoseconds
        TotalAssertions    int     `json:"totalAssertions"`    // Total number of assertions evaluated
        FailedAssertions   int     `json:"failedAssertions"`   // Number of failed assertions
}

// PerformanceInfo contains performance monitoring data
type PerformanceInfo struct {
        SpecsProcessed       int     `json:"specsProcessed"`       // Number of specs processed
        SpansMatched         int     `json:"spansMatched"`         // Number of spans matched
        AssertionsEvaluated  int     `json:"assertionsEvaluated"`  // Total assertions evaluated
        ConcurrentWorkers    int     `json:"concurrentWorkers"`    // Number of concurrent workers used
        MemoryUsageMB        float64 `json:"memoryUsageMB"`        // Peak memory usage in MB
        ProcessingRate       float64 `json:"processingRate"`       // Specs processed per second
}

// AlignmentResult represents the result of aligning a single ServiceSpec with trace data
type AlignmentResult struct {
        SpecOperationID   string            `json:"specOperationId"`
        Status            AlignmentStatus   `json:"status"`
        Details           []ValidationDetail `json:"details"`
        ExecutionTime     int64             `json:"executionTime"`     // Duration in nanoseconds
        StartTime         int64             `json:"startTime"`         // Start timestamp in Unix nanoseconds
        EndTime           int64             `json:"endTime"`           // End timestamp in Unix nanoseconds
        MatchedSpans      []string          `json:"matchedSpans"`      // IDs of spans that matched this spec
        AssertionsTotal   int               `json:"assertionsTotal"`   // Total number of assertions evaluated
        AssertionsPassed  int               `json:"assertionsPassed"`  // Number of assertions that passed
        AssertionsFailed  int               `json:"assertionsFailed"`  // Number of assertions that failed
        ErrorMessage      string            `json:"errorMessage,omitempty"` // Error message if processing failed
}

// AlignmentStatus represents the status of an alignment result
type AlignmentStatus string

const (
        StatusSuccess AlignmentStatus = "SUCCESS"
        StatusFailed  AlignmentStatus = "FAILED"
        StatusSkipped AlignmentStatus = "SKIPPED"
)

// ValidationDetail provides detailed information about a specific validation
type ValidationDetail struct {
        Type          string                 `json:"type"`                    // "precondition" | "postcondition"
        Expression    string                 `json:"expression"`
        Expected      interface{}            `json:"expected"`
        Actual        interface{}            `json:"actual"`
        Message       string                 `json:"message"`
        SpanContext   *Span                  `json:"spanContext,omitempty"`
        FailureReason string                 `json:"failureReason,omitempty"` // Detailed analysis of why the assertion failed
        ContextInfo   map[string]interface{} `json:"contextInfo,omitempty"`   // Additional context information for debugging
        Suggestions   []string               `json:"suggestions,omitempty"`   // Actionable suggestions for fixing the failure
}

// AddResult adds an alignment result to the report and updates the summary
func (ar *AlignmentReport) AddResult(result AlignmentResult) <span class="cov8" title="1">{
        ar.Results = append(ar.Results, result)
        ar.updateSummary()
}</span>

// updateSummary recalculates the summary statistics based on current results
func (ar *AlignmentReport) updateSummary() <span class="cov8" title="1">{
        total := len(ar.Results)
        success := 0
        failed := 0
        skipped := 0
        totalExecutionTime := int64(0)
        totalAssertions := 0
        failedAssertions := 0

        for _, result := range ar.Results </span><span class="cov8" title="1">{
                switch result.Status </span>{
                case StatusSuccess:<span class="cov8" title="1">
                        success++</span>
                case StatusFailed:<span class="cov8" title="1">
                        failed++</span>
                case StatusSkipped:<span class="cov8" title="1">
                        skipped++</span>
                }
                
                <span class="cov8" title="1">totalExecutionTime += result.ExecutionTime
                totalAssertions += result.AssertionsTotal
                failedAssertions += result.AssertionsFailed</span>
        }

        <span class="cov8" title="1">ar.Summary = AlignmentSummary{
                Total:           total,
                Success:         success,
                Failed:          failed,
                Skipped:         skipped,
                TotalAssertions: totalAssertions,
                FailedAssertions: failedAssertions,
        }

        // Calculate rates
        if total &gt; 0 </span><span class="cov8" title="1">{
                ar.Summary.SuccessRate = float64(success) / float64(total)
                ar.Summary.FailureRate = float64(failed) / float64(total)
                ar.Summary.SkipRate = float64(skipped) / float64(total)
                ar.Summary.AverageExecutionTime = totalExecutionTime / int64(total)
        }</span>
}

// HasFailures returns true if any alignment results have failed
func (ar *AlignmentReport) HasFailures() bool <span class="cov8" title="1">{
        return ar.Summary.Failed &gt; 0
}</span>

// GetSuccessRate returns the success rate as a percentage (0.0 to 1.0)
func (ar *AlignmentReport) GetSuccessRate() float64 <span class="cov8" title="1">{
        if ar.Summary.Total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(ar.Summary.Success) / float64(ar.Summary.Total)</span>
}

// GetFailureRate returns the failure rate as a percentage (0.0 to 1.0)
func (ar *AlignmentReport) GetFailureRate() float64 <span class="cov8" title="1">{
        if ar.Summary.Total == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float64(ar.Summary.Failed) / float64(ar.Summary.Total)</span>
}

// String returns a string representation of the AlignmentStatus
func (as AlignmentStatus) String() string <span class="cov8" title="1">{
        return string(as)
}</span>

// IsValid returns true if the AlignmentStatus is one of the valid values
func (as AlignmentStatus) IsValid() bool <span class="cov8" title="1">{
        switch as </span>{
        case StatusSuccess, StatusFailed, StatusSkipped:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// AddValidationDetail adds a validation detail to the alignment result
func (ar *AlignmentResult) AddValidationDetail(detail ValidationDetail) <span class="cov8" title="1">{
        ar.Details = append(ar.Details, detail)
        
        // Update status based on validation details
        ar.updateStatus()
}</span>

// updateStatus updates the alignment result status based on validation details
func (ar *AlignmentResult) updateStatus() <span class="cov8" title="1">{
        if len(ar.Details) == 0 </span><span class="cov0" title="0">{
                ar.Status = StatusSkipped
                ar.AssertionsTotal = 0
                ar.AssertionsPassed = 0
                ar.AssertionsFailed = 0
                return
        }</span>

        <span class="cov8" title="1">totalAssertions := 0
        passedAssertions := 0
        failedAssertions := 0
        hasFailure := false

        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                // Skip "matching" type details as they are not assertions
                if detail.Type == "matching" </span><span class="cov0" title="0">{
                        continue</span>
                }
                
                <span class="cov8" title="1">totalAssertions++
                
                // Check if this assertion passed or failed
                if detail.IsPassed() </span><span class="cov8" title="1">{
                        passedAssertions++
                }</span> else<span class="cov8" title="1"> {
                        failedAssertions++
                        hasFailure = true
                }</span>
        }

        <span class="cov8" title="1">ar.AssertionsTotal = totalAssertions
        ar.AssertionsPassed = passedAssertions
        ar.AssertionsFailed = failedAssertions

        // Determine overall status
        if hasFailure </span><span class="cov8" title="1">{
                ar.Status = StatusFailed
        }</span> else<span class="cov8" title="1"> if totalAssertions &gt; 0 </span><span class="cov8" title="1">{
                ar.Status = StatusSuccess
        }</span> else<span class="cov0" title="0"> {
                ar.Status = StatusSkipped
        }</span>
}

// GetFailedDetails returns only the validation details that failed
func (ar *AlignmentResult) GetFailedDetails() []ValidationDetail <span class="cov8" title="1">{
        var failed []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Expected != detail.Actual </span><span class="cov8" title="1">{
                        failed = append(failed, detail)
                }</span>
        }
        <span class="cov8" title="1">return failed</span>
}

// GetPreconditionDetails returns only the precondition validation details
func (ar *AlignmentResult) GetPreconditionDetails() []ValidationDetail <span class="cov8" title="1">{
        var preconditions []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Type == "precondition" </span><span class="cov8" title="1">{
                        preconditions = append(preconditions, detail)
                }</span>
        }
        <span class="cov8" title="1">return preconditions</span>
}

// GetPostconditionDetails returns only the postcondition validation details
func (ar *AlignmentResult) GetPostconditionDetails() []ValidationDetail <span class="cov8" title="1">{
        var postconditions []ValidationDetail
        for _, detail := range ar.Details </span><span class="cov8" title="1">{
                if detail.Type == "postcondition" </span><span class="cov8" title="1">{
                        postconditions = append(postconditions, detail)
                }</span>
        }
        <span class="cov8" title="1">return postconditions</span>
}

// String returns a string representation of the ValidationDetail
func (vd *ValidationDetail) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ValidationDetail{Type: %s, Expression: %s, Expected: %v, Actual: %v}",
                vd.Type, vd.Expression, vd.Expected, vd.Actual)
}</span>

// IsPassed returns true if the validation detail passed (expected equals actual)
func (vd *ValidationDetail) IsPassed() bool <span class="cov8" title="1">{
        return vd.Expected == vd.Actual
}</span>

// NewAlignmentReport creates a new empty alignment report
func NewAlignmentReport() *AlignmentReport <span class="cov8" title="1">{
        return &amp;AlignmentReport{
                Summary: AlignmentSummary{},
                Results: []AlignmentResult{},
        }
}</span>

// NewAlignmentResult creates a new alignment result with the given operation ID
func NewAlignmentResult(operationID string) *AlignmentResult <span class="cov8" title="1">{
        return &amp;AlignmentResult{
                SpecOperationID: operationID,
                Status:          StatusSkipped, // Default to skipped until validation details are added
                Details:         []ValidationDetail{},
                ExecutionTime:   0,
        }
}</span>

// NewValidationDetail creates a new validation detail
func NewValidationDetail(detailType, expression string, expected, actual interface{}, message string) *ValidationDetail <span class="cov8" title="1">{
        return &amp;ValidationDetail{
                Type:       detailType,
                Expression: expression,
                Expected:   expected,
                Actual:     actual,
                Message:    message,
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
